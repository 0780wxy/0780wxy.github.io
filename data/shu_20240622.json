{
    "name": "2024数据库概论",
    "uuid": "2951981D-1CD2-8BC5-3390-C53A1EB1C2F9",
    "data": [
        {
            "question": "事务的 ACID 性质中，关于原子性(atomicity)的描述正确的是 【1】 。",
            "true": [
                "事务中的所有操作要么都执行，要么都不执行"
            ],
            "false": [
                "指数据库的内容不出现矛盾的状态",
                "若事务正常结束，即使发生故障，更新结果也不会从数据库中消失",
                "若多个事务同时进行，与顺序实现的处理结果是一致的"
            ]
        },{
            "question": "关于事务的故障与恢复，下列描述正确的是 【1】 。",
            "true": [
                "对日志文件设立检查点目的是为了提高故障恢复的效率 "
            ],
            "false": [
                "事务日志是用来记录事务执行的频度",
                "采用增量备份，数据的恢复可以不使用事务日志文件",
                "系统故障的恢复只需进行重做(Redo)操作"
            ]
        },{
            "question": "一个事务执行过程中，其正在访问的数据被其他事务所修改，导致处理结果不正确，这是由于违背了事务的  【1】  的。",
            "true": [
                "隔离性"
            ],
            "false": [
                "原子性",
                "一致性",
                "持久性"
            ]
        },{
            "question": "在SQL语言中事务结束的命令是  【1】  。",
            "true": [
                "COMMIT或ROLLBACK"
            ],
            "false": [
                "END TRANSACTION",
                "COMMIT",
                "ROLLBACK"
            ]
        },{
            "question": "对事务回滚的正确描述是  【1】  。",
            "true": [
                "将该事务对数据库的修改进行恢复"
            ],
            "false": [
                "将事务对数据库的更新写入硬盘",
                "跳转到事务程序的开头重新执行",
                "将事务中修改的变量值恢复到事务开始时的初值"
            ]
        },{
            "question": "对事务日志的正确描述是  【1】  。",
            "true": [
                "事务日志必须严格按照对数据库进行修改的时间次序记录"
            ],
            "false": [
                "事务日志记录了对数据库的所有操作",
                "事务日志文件应该与数据库文件放在同一存储设备上",
                "事务日志的主要目的是应用于审计"
            ]
        },{
            "question": "介质故障恢复需采取以下操作，其操作步骤是  【1】  。\nⅠ．装载数据备份    Ⅱ．执行Redo操作    Ⅲ．执行Undo操作",
            "true": [
                "Ⅰ-＞Ⅲ-＞Ⅱ"
            ],
            "false": [
                "Ⅰ-＞Ⅱ-＞Ⅲ",
                "Ⅱ-＞Ⅰ-＞Ⅲ",
                "Ⅱ-＞Ⅲ-＞Ⅰ"
            ]
        },{
            "question": "有关动态增量备份的描述正确的是：  【1】  。",
            "true": [
                "动态增量备份宜在事务不繁忙时进行"
            ],
            "false": [
                "动态增量备份会备出全部数据",
                "动态增量备份过程不允许外部事务程序访问数据库",
                "动态增量备份装载后数据库即处于一致性状态"
            ]
        },{
            "question": "“一旦事务成功提交，其对数据库的更新操作将永久有效，即使数据库发生故障”，这一性质是指事务的  【1】  。",
            "true": [
                "持久性"
            ],
            "false": [
                "原子性",
                "一致性",
                "隔离性"
            ]
        },{
            "question": "在事务处理的过程中，DBMS把事务开始、事务结束以及对数据库的插入、删除和修改的每一次操作写入  【1】  文件。",
            "true": [
                "日志"
            ],
            "false": [
                "目录",
                "用户",
                "系统"
            ]
        },{
            "question": "输入数据违反完整性约束导致的数据库故障属于  【1】  。",
            "true": [
                "事务故障"
            ],
            "false": [
                "系统故障",
                "介质故障",
                "网络故障"
            ]
        },{
            "question": "在有事务运行时转储全部数据库的方式是  【1】  。",
            "true": [
                "动态海量转储"
            ],
            "false": [
                "静态增量转储",
                "静态海量转储",
                "动态增量转储"
            ]
        },{
            "question": "对于数据库恢复，下列描述正确的是  【1】  。",
            "true": [
                "事务故障恢复时需要逆向扫描日志对未完成事务进行UNDO操作"
            ],
            "false": [
                "介质故障的恢复不需要DBA的参与，由DBMS自动完成",
                "日志文件严格按照事务的请求时间顺序进行记录",
                "检查点时刻的数据库一定是处于一致性状态的"
            ]
        },{
            "question": "“一个事务中的诸操作要么都做，要么都不做”，这一性质是指事务的  【1】  。",
            "true": [
                "原子性"
            ],
            "false": [
                "一致性",
                "隔离性",
                "持久性"
            ]
        },{
            "question": "当事务程序执行回滚指令时，事务进入  【1】  状态。",
            "true": [
                "中止"
            ],
            "false": [
                "提交",
                "活动",
                "失败"
            ]
        },{
            "question": "事务故障恢复的描述，正确的是  【1】  。",
            "true": [
                "事务故障的恢复只需要日志，不需DBA参与"
            ],
            "false": [
                "事务故障的恢复必须DBA参与",
                "事务故障的恢复需要数据库复本",
                "事务故障的恢复需要日志和数据库复本"
            ]
        },{
            "question": "由于软硬件故障可能造成数据库中数据被破坏，数据库恢复就是  【1】  。具体的实现方法有多种，如：定期将数据库作备份；在进行事务处理时，对数据更新(插入、删除、修改)的全部有关内容写入日志文件；当系统正常运行时，按一定的时间间隔，设立检查点文件，把内存缓冲区内容还未写入到磁盘中去的有关状态记录到该文件中；当发生故障时，根据现场数据内容及相关文件来恢复系统的状态。",
            "true": [
                "在尽可能短的时间内，把数据库恢复到故障发生前的状态"
            ],
            "false": [
                "重新安装数据库管理系统和应用程序",
                "重新安装应用程序，并将数据库做镜像",
                "重新安装数据库管理系统，并将数据库做镜像"
            ]
        },{
            "question": "由于软硬件故障可能造成数据库中数据被破坏，数据库恢复就是在尽可能短的时间内，把数据库恢复到故障发生前的状态。具体的实现方法有多种，如：定期将数据库作备份；在进行事务处理时，对数据更新(插入、删除、修改)的全部有关内容写入  【2】  ；当系统正常运行时，按一定的时间间隔，设立检查点文件，把内存缓冲区内容还未写入到磁盘中去的有关状态记录到该文件中；当发生故障时，根据现场数据内容及相关文件来恢复系统的状态。",
            "true": [
                "日志文件"
            ],
            "false": [
                "检查点文件",
                "程序文件",
                "图像文件"
            ]
        },{
            "question": "由于软硬件故障可能造成数据库中数据被破坏，数据库恢复就是在尽可能短的时间内，把数据库恢复到故障发生前的状态。具体的实现方法有多种，如：定期将数据库作备份；在进行事务处理时，对数据更新(插入、删除、修改)的全部有关内容写入日志文件；当系统正常运行时，按一定的时间间隔，设立 【3】  ，把内存缓冲区内容还未写入到磁盘中去的有关状态记录到该文件中；当发生故障时，根据现场数据内容及相关文件来恢复系统的状态。",
            "true": [
                "检查点文件"
            ],
            "false": [
                "日志文件",
                "程序文件",
                "图像文件"
            ]
        },{
            "question": "关于备份策略的描述，正确的是  【1】  。",
            "true": [
                "数据更新量小时适合做动态备份"
            ],
            "false": [
                "静态备份应经常进行",
                "动态备份适合在事务请求频繁时进行",
                "海量备份适合在事务请求频繁时进行"
            ]
        },{
            "question": "事务回滚指令ROLLBACK执行的结果是  【1】  。",
            "true": [
                "撤销该事务对数据库的所有的INSERT、UPDATE、DELETE操作"
            ],
            "false": [
                "跳转到事务程序开始处继续执行",
                "将事务中所有变量值恢复到事务开始时的初值",
                "跳转到事务程序结束处继续执行"
            ]
        },{
            "question": "某公司的数据库应用系统中，其数据库服务器配置两块物理硬盘，可以采用下述存储策略：\n①将表和索引放在同一硬盘的不同逻辑分区以提高性能；\n②将表和索引放在不同硬盘以提高性能；\n③将日志文件和数据库文件放在同一硬盘的不同逻辑分区以提高性能；\n④将日志文件和数据库文件放在不同硬盘以提高性能；\n⑤将备份文件和日志文件与数据库文件放在同一硬盘以保证介质故障时能够恢复\n一个比较正确合理的存储策略是  【1】  。",
            "true": [
                "② ④"
            ],
            "false": [
                "① ④",
                "① ③ ⑤",
                "② ③"
            ]
        },{
            "question": "下列故障中属于事务内部故障的是  【1】  。",
            "true": [
                "违反完整性约束"
            ],
            "false": [
                "程序中ROLLBACK语句",
                "CPU故障",
                "硬盘损坏"
            ]
        },{
            "question": "对于事务故障的恢复，下列描述正确的是  【1】  。",
            "true": [
                "事务故障恢复时需要反向扫描日志，对该事务进行UNDO操作"
            ],
            "false": [
                "事务故障的恢复不需要访问日志文件",
                "事务故障恢复时需要REDO已提交的事务",
                "事务故障恢复时需要正向扫描日志，对该事务进行UNDO操作"
            ]
        },{
            "question": "数据库镜像技术的优点是  【1】  。",
            "true": [
                "复制技术可以在镜像数据库发生故障时保证系统稳定运行"
            ],
            "false": [
                "可以减少事务故障的机率可以减少事务故障的机率",
                "可以提高更新事务的并发度",
                "维护镜像数据库的一致性不需要额外的开销"
            ]
        },{
            "question": "事务提交(COMMIT)后，对数据库的更新操作可能还停留在服务器的磁盘缓冲区中，而未写入到磁盘，即使此时系统出现故障，事务的执行结果仍不会丢失，称为事务的  【1】  。为保证事务的此性质，需要利用数据库的日志文件。 ",
            "true": [
                "持久性"
            ],
            "false": [
                "原子性",
                "一致性",
                "隔离性"
            ]
        },{
            "question": "事务提交(COMMIT)后，对数据库的更新操作可能还停留在服务器的磁盘缓冲区中，而未写入到磁盘，即使此时系统出现故障，事务的执行结果仍不会丢失，称为事务的持久性。为保证事务的此性质，需要利用数据库的  【2】  。 ",
            "true": [
                "日志文件"
            ],
            "false": [
                "全局备份",
                "增量备份",
                "影子备份"
            ]
        },{
            "question": " 若事务程序中有表达式a/b，如果b取值为0时计算该表达式，会产生的故障属于__【1】____。",
            "true": [
                "事务故障"
            ],
            "false": [
                "系统故障",
                "介质故障",
                "死机"
            ]
        },{
            "question": " 系统故障的恢复___【1】___。",
            "true": [
                "仅需要使用日志"
            ],
            "false": [
                "仅需要使用备份",
                "必须使用日志和备份",
                "仅需要使用日志或备份"
            ]
        },{
            "question": "假设日志文件的尾部如下图所示，则恢复时应执行的操作是___【1】___。＜T0 start＞\n＜T0，A，1000，950＞\n＜T1 start＞\n＜T1，C，700，600＞\n＜T0，B，2000，2050＞\n＜T0 commit＞",
            "true": [
                "Undo T1，Redo T0"
            ],
            "false": [
                "Undo T0，Redo T1",
                "Redo T0，Redo T1",
                "Undo T1，Undo T0"
            ]
        },{
            "question": "一个事务的执行，不应该受到其他事务的干扰而影响其结果的正确性，称为事务的__【1】____。",
            "true": [
                "隔离性"
            ],
            "false": [
                "原子性",
                "一致性",
                "持久性"
            ]
        },{
            "question": "关于ROLLBACK的描述，正确的是__【1】____。",
            "true": [
                "ROLLBACK语句会将事务对数据库的更新撤消"
            ],
            "false": [
                "ROLLBACK语句会将事务对数据库的更新写入数据库",
                "ROLLBACK语句会退出事务所在程序",
                "ROLLBACK语句能够将事务中使用的所有变量置空值"
            ]
        },{
            "question": "假设系统中有运行的事务，若要转储全部数据库应采用（【1】）方式。",
            "true": [
                "动态全局转储"
            ],
            "false": [
                "静态全局转储",
                "静态增量转储",
                "动态增量转储"
            ]
        },{
            "question": "SQL中，用于提交和回滚事务的语句分别是（【1】）。",
            "true": [
                "COMMIT WORK和ROLLBACK WORK"
            ],
            "false": [
                "END WORK和ROLLBACK WORK",
                "SAVE WORK和ROLLUP WORK",
                "COMMITWORK和ROLLUP WORKB"
            ]
        },{
            "question": "事务有多种性质，“一旦事务成功提交，即使数据库崩溃，其对数据库的更新操作也将永久有效。”这一性质属于事务的（【1】）性质。",
            "true": [
                "持久性"
            ],
            "false": [
                "原子性",
                "一致性",
                "隔离性"
            ]
        },{
            "question": "以下对数据库故障的描述中，不正确的是【1】。",
            "true": [
                "系统故障一定会导致磁盘数据丢失"
            ],
            "false": [
                "系统故障指软硬件错误导致的系统崩溃",
                "由于事务内部的逻辑错误造成该事务无法执行的故障属于事务故障",
                "可通过数据的异地备份来减少磁盘故障可能给数据库系统造成数据丢失"
            ]
        },{
            "question": "在日志中加入检查点，可【1】。",
            "true": [
                "提高一并故障恢复的效率"
            ],
            "false": [
                "减少并发冲突",
                "避免级联回滚",
                "避免死锁"
            ]
        },{
            "question": "在SQL中，通过使用 COMMIT和和 ROLLBACK语句可以结束事务。以下说法正确的是__【1】__。",
            "true": [
                "某事务执行了 ROLLBACK语句，可将其对数据库的更新撤消"
            ],
            "false": [
                "某事务执行了 ROLLBACK语句，表示事务正确地执行完毕",
                "某事务执行了 ROLLBACK语句，可将其对数据库的更新写入数据库",
                "某事务执行了 COMIMIIT语句，其影响可用 ROLLBACK语句来撤销"
            ]
        },{
            "question": "以下对数据转储的叙述中，不正确的是（ 【1】）",
            "true": [
                "动态转储在转储期间允许对数据库进行读取，但不允许更新"
            ],
            "false": [
                "静态转储在转储期间不允许对数据库进行更新",
                "海量转储是指每次转储全部数据",
                "增量转储是指每次只转储上次转储后更新过的数据"
            ]
        },{
            "question": "设置日志文件的目的不包括__【1】__",
            "true": [
                "删除计算机病毒"
            ],
            "false": [
                "事务故障恢复",
                "系统故障恢复",
                "介质故障恢复"
            ]
        },{
            "question": "一级封锁协议解决了事务的并发操作带来的  【1】  不一致性的问题。",
            "true": [
                "数据丢失修改"
            ],
            "false": [
                "数据不可重复读",
                "读脏数据",
                "数据重复修改"
            ]
        },{
            "question": "【1】  能保证不产生死锁。",
            "true": [
                "一次封锁法"
            ],
            "false": [
                "两段锁协议",
                "2级封锁协议",
                "3级封锁协议"
            ]
        },{
            "question": "【1】  ，数据库处于一致性状态。",
            "true": [
                "采用静态副本恢复后"
            ],
            "false": [
                "事务执行过程中",
                "突然断电后",
                "缓冲区数据写入数据库后"
            ]
        },{
            "question": "遵循两段锁协议的事务程序能够解决并发事务对数据库操作的不一致性不包括：  【1】  。",
            "true": [
                "不可重复写"
            ],
            "false": [
                "丢失修改",
                "不可重复读",
                "读脏数据"
            ]
        },{
            "question": "针对分布式事务，要求提供参与者状态的协议是  【1】  。",
            "true": [
                "三阶段提交协议"
            ],
            "false": [
                "一次封锁协议",
                "两段锁协议",
                "两阶段提交协议"
            ]
        },{
            "question": "若数据A持有事务T1所加的排它锁，那么其他事务对数据A  【1】  。",
            "true": [
                "加共享锁、加排它锁都失败"
            ],
            "false": [
                "加共享锁成功，加排它锁失败",
                "加排它锁成功，加共享锁失败",
                "加共享锁、加排它锁都成功"
            ]
        },{
            "question": "火车售票点T1、T2分别售出了两张2007年10月20 到北京的硬卧票，但数据库里的剩余票数却只减了两张，造成数据的不一致，原因是  【1】  。",
            "true": [
                "丢失了某售票点修改"
            ],
            "false": [
                "系统信息显示出错",
                "售票点重复读数据",
                "售票点读了“脏”数据"
            ]
        },{
            "question": "若系统中存在5个等待事务T0，T1，T2，T3，T4，其中：T0正等待被T1锁住的数据项A1， T1正等待被T2锁住的数据项A2，T2正等待被T3锁住的数据项A3，T3正等待被T4锁住的数据项A4，T4正等待被T0锁住的数据项A0，则系统处于  【1】  的工作状态。",
            "true": [
                "死锁"
            ],
            "false": [
                "并发处理",
                "封锁",
                "循环"
            ]
        },{
            "question": "幻影现象属于哪类数据不一致，  【1】  。",
            "true": [
                "不可重复读"
            ],
            "false": [
                "丢失修改",
                "读脏数据",
                "事务故障"
            ]
        },{
            "question": "根据分布式数据库系统中的两阶段提交协议(2PC)，有如下操作指令：\n①协调器向参与者发prepare消息；    ②参与者向协调器发回ready消息；\n③参与者向协调器发回abort消息；     ④协调器向参与者发commit消息；\n⑤协调器向参与者发rollback消息。\n满足2PC的序列是  【1】  。",
            "true": [
                "①②④"
            ],
            "false": [
                "①②⑤",
                "②③⑤",
                "②③④"
            ]
        },{
            "question": "以下关于事务调度的叙述中，错误的是__【1】__ 。",
            "true": [
                "2PL能够保证不产生死锁"
            ],
            "false": [
                "串行调度是指一个事务执行完再执行下一个事务",
                "可串行化调度是正确的调度",
                "2PL能够保证可串行化调度"
            ]
        },{
            "question": "保证并发调度的可串行化，是为了确保事务的【1】。",
            "true": [
                "隔离性和一致性"
            ],
            "false": [
                "原子性和一致性",
                "原子性和持久性",
                "隔离性和持久性"
            ]
        },{
            "question": "满足两阶段封锁协议的调度一定是【1】。",
            "true": [
                "可串行化调度"
            ],
            "false": [
                "无死锁的调度",
                "可恢复调度",
                "可避免级联回滚的调度"
            ]
        },{
            "question": "数据库的并发操作可能带来的问题包括（【1】）",
            "true": [
                "丢失修改"
            ],
            "false": [
                "增加数据冗余度",
                "增强数据独立性",
                "非授权访问"
            ]
        },{
            "question": "在数据库事务的四种隔离级别中，不能避免脏读的是（【1】）。",
            "true": [
                "Read committed"
            ],
            "false": [
                "Read uncommitted",
                "Repeatable read",
                "Serializable"
            ]
        },{
            "question": "为了防止一个事务的执行影响其他事务，应该采取__【1】__。",
            "true": [
                "并发控制"
            ],
            "false": [
                "索引机制",
                "故障恢复",
                "完整性约束"
            ]
        },{
            "question": "解决并发操作带来的数据不一致性一般采用__【1】__",
            "true": [
                "封锁"
            ],
            "false": [
                "恢复",
                "授权",
                "协商"
            ]
        },{
            "question": "以下是平行数据库的四种体系结构，在【1】体系结构中所有处理器共享一个公共的主存储器和磁盘。",
            "true": [
                "共享内存"
            ],
            "false": [
                "共享磁盘",
                "无共享",
                "层次"
            ]
        },{
            "question": "分布式数据库的垂直分片中，为保证全局数据的可重构和最小冗余，分片满足的必要条件是  【1】  。",
            "true": [
                "对于任一分片，总存在另一个分片能够和它进行无损连接"
            ],
            "false": [
                "要有两个分片具有相同关系模式以进行并操作",
                "任意两个分片不能有相同的属性名",
                "各分片必须包含原关系的码"
            ]
        },{
            "question": "分布式数据库中，  【1】  是指各场地数据的逻辑结构对用户不可见。",
            "true": [
                "局部数据模型透明性"
            ],
            "false": [
                "分片透明性",
                "场地透明性",
                "场地自治"
            ]
        },{
            "question": "分布式数据库两阶段提交协议是指  【1】  。",
            "true": [
                "表决阶段、执行阶段"
            ],
            "false": [
                "加锁阶段、解锁阶段",
                "扩展阶段、收缩阶段",
                "获取阶段、运行阶段"
            ]
        },{
            "question": "在基于Web的电子商务应用中，业务对象常用的数据库访问方式之一是  【1】  。",
            "true": [
                "JDBC"
            ],
            "false": [
                "COM",
                "CGI",
                "XML"
            ]
        },{
            "question": "以下SQL 99语句描述的是  【1】  。\nCREATE TYPE Employee(\nname String，\nssn integer)；\nCREATE TYPE Manager\n    UNDER Employee(\n     degree String，\n     dept String)；",
            "true": [
                "继承类型"
            ],
            "false": [
                "关联关系",
                "嵌套关系",
                "聚集关系"
            ]
        },{
            "question": "分布式数据库的场地自治性访问的是  【1】  。",
            "true": [
                "局部概念层"
            ],
            "false": [
                "全局概念层",
                "全局外层",
                "局部内层"
            ]
        },{
            "question": "并行数据库体系结构中具有独立处理机、内存和磁盘的是  【1】  结构。",
            "true": [
                "无共享"
            ],
            "false": [
                "共享内存",
                "共亨磁盘",
                "共享内存和磁盘"
            ]
        },{
            "question": "首先提出支持面向对象数据模型的SQL标准是  【1】  。",
            "true": [
                "SQL99"
            ],
            "false": [
                "SQL86",
                "SQL89",
                "SQL92"
            ]
        },{
            "question": "面向对象数据模型中不包含  【1】  。",
            "true": [
                "对象实例"
            ],
            "false": [
                "属性集合",
                "方法集合",
                "消息集合"
            ]
        },{
            "question": "XML与数据转存时，不需要考虑的问题是  【1】  。",
            "true": [
                "基本属性的次序"
            ],
            "false": [
                "XML文档结构和数据库结构之间的映射",
                "利用数据库保存文档还是数据",
                "XML中类型的约束与数据库的约束"
            ]
        },{
            "question": "在C/S体系结构中，客户端连接数据不需要指定的是  【1】",
            "true": [
                "应用系统用户名和密码"
            ],
            "false": [
                "数据库服务器地址",
                "数据库用户名和密码",
                "连接端口"
            ]
        },{
            "question": "不属于数据库访问接口的是  【1】  。",
            "true": [
                "XML"
            ],
            "false": [
                "ODBC",
                "JDBC",
                "ADO"
            ]
        },{
            "question": "分布式数据库中每个节点都能够执行局部应用请求，是指  【1】  。",
            "true": [
                "场地自治性"
            ],
            "false": [
                "数据分布性",
                "逻辑相关性",
                "场地透明性"
            ]
        },{
            "question": "分布式事务故障不同于集中式事务故障的是  【1】  。",
            "true": [
                "通信故障"
            ],
            "false": [
                "介质故障",
                "系统故障",
                "事务故障"
            ]
        },{
            "question": "除了一般数据库系统要解决的主要问题外，并行数据库中还要解决的主要问题是  【1】  。",
            "true": [
                "任务分解"
            ],
            "false": [
                "CPU监控",
                "I/O处",
                "事务处理"
            ]
        },{
            "question": "以下可以完成对象—关系映射的工具是  【1】  。",
            "true": [
                "Hibernate"
            ],
            "false": [
                "Spring",
                "Spring",
                "MVC"
            ]
        },{
            "question": "对含有BLOB型数据(如图片、声音等)的关系模式，从优化的角度考虑，应采用的设计方案是  【1】  。",
            "true": [
                "将BLOB字段与关系的码独立为一张表"
            ],
            "false": [
                "将BLOB字段独立为一张表",
                "对已满足规范化要求的表不做分解",
                "将BLOB对象作为文件存储"
            ]
        },{
            "question": "分布式数据库用户无需知道数据的物理位置，称为  【1】  。",
            "true": [
                "位置透明"
            ],
            "false": [
                "复制透明",
                "分片透明",
                "逻辑透明"
            ]
        },{
            "question": "分布式数据库能够提高某些查询效率是因为其具有  【1】  。",
            "true": [
                "数据复本"
            ],
            "false": [
                "数据分片",
                "基于同构模式",
                "基于异构模式"
            ]
        },{
            "question": "以下的SQL 99语句，Dept与Employee之间的关系是  【1】  。\n  CREATE TYPE Employee(\n  name string,\n  ssn integer);\n  CREATE TYPE Dept(\n  Name string\n  Head ref (Employee)SCOPE Employee  );",
            "true": [
                "类型引用"
            ],
            "false": [
                "类型继承",
                "数据引用",
                "无任何关系"
            ]
        },{
            "question": "B/S体系结构中属于客户端的是  【1】  。",
            "true": [
                "浏览器"
            ],
            "false": [
                "Web服务器",
                "应用服务器",
                "数据库服务器"
            ]
        },{
            "question": "对象一关系模型与关系模型的区别是  【1】  。",
            "true": [
                "对象一关系模型支持关系嵌套，关系模型不支持"
            ],
            "false": [
                "关系模型支持BLOB类型，对象一关系模型不支持",
                "对象—关系模型不支持数组类型，关系模型支持",
                "对象一关系模型不是数据模型，关系模型是数据模型"
            ]
        },{
            "question": "在分布式数据库系统中，应用程序直接使用本节点数据的性质称为  【1】  。",
            "true": [
                "自治性"
            ],
            "false": [
                "共享性",
                "可用性",
                "分布性"
            ]
        },{
            "question": "SQL-99标准规定的事务的四个隔离级别中，能解决幻影读现象的级别是___【1】___。 ",
            "true": [
                "SERIALIZABLE"
            ],
            "false": [
                "READ COMMITTED",
                "READ UNCOMMITTED",
                "REPEATABLE READ"
            ]
        },{
            "question": "关于分布式数据库，下列描述正确的是___【1】___。 ",
            "true": [
                "数据的物理存储分布在不同的服务器上，而用户只关心访问的逻辑结构"
            ],
            "false": [
                "客户机是分布在不同场地的",
                "多个数据库服务器间的数据交互通过客户端程序来实现",
                "每个服务器上必须运行相同的DBMS"
            ]
        },{
            "question": "分布式数据库允许部分数据存在多个复本，而用户不必知道这些复本的存在，称为__【1】____。",
            "true": [
                "复制透明"
            ],
            "false": [
                "分片透明",
                "位置透明",
                "全局共享"
            ]
        },{
            "question": "不属于数据库访问接口的是_【1】_____。 ",
            "true": [
                "HTML"
            ],
            "false": [
                "ODBC",
                "JDBC",
                "ADO"
            ]
        },{
            "question": " C/S(客户机/服务器)与B/S(浏览器/服务器)体系结构的区别是：__【1】____。",
            "true": [
                "B/S较C/S易于维护"
            ],
            "false": [
                "B/S建立在局域网上，C/S建立在广域网上",
                "B/S客户相对固定集中，C/S客户分散",
                "B/S软件重用性弱于C/S"
            ]
        },{
            "question": "以下的SQL99语句，Student与Person之间的关系是___【1】___。\n    CREATE  TYPE  Person(\n    name char(20),\n    address varchar(50)  );\n    CREATE  TYPE  Student(\n    under  Person\n    (degree char(20)\n    department char(20)  );",
            "true": [
                "类型继承"
            ],
            "false": [
                "类型引用",
                "表继承",
                "无任何关系"
            ]
        },{
            "question": "银行系统采用分布式数据库系统，对本地储户的存储业务能够在本地正常进行，而不依赖于其他场地数据库，称为分布式数据库的___【1】___。",
            "true": [
                "自治性"
            ],
            "false": [
                "共享性",
                "可用性",
                "分布性"
            ]
        },{
            "question": "以下关于面向对象数据模型的叙述中，错误的是__【1】__。",
            "true": [
                "对象中的属性和方法对外界是不可见的"
            ],
            "false": [
                "一个对象对应着E-R模型中的一个实体",
                "对象类是一系列相似对象的集合",
                "对象之间的相互作用通过消息来实现"
            ]
        },{
            "question": " 下表中两个事务的调度带来的问题是__【1】__。",
            "true": [
                "不可重复读"
            ],
            "false": [
                "丢失修改",
                "读脏数据",
                "没有问题"
            ]
        },{
            "question": "采用二维表格结构表达实体及实体间联系的数据模型是  【1】  。",
            "true": [
                "关系模型"
            ],
            "false": [
                "层次模型",
                "网状模型",
                "面向对象模型"
            ]
        },{
            "question": "数据库的视图、基本表和存储文件的结构分别对应__【1】____。 ",
            "true": [
                "外模式、模式、内模式 "
            ],
            "false": [
                "模式、内模式、外模式",
                "模式、外模式、内模式",
                "外模式、内模式、模式"
            ]
        },{
            "question": "以下属于DBA职责的是__【1】__ 。",
            "true": [
                "系统故障恢复"
            ],
            "false": [
                "开发应用程序",
                "负责系统设计",
                "负责调试安装"
            ]
        },{
            "question": "在采用三级模式结构的数据库系统中，如果对数据库中的表Emp创建聚簇索引那么应该改变的是数据库的（【1】）。",
            "true": [
                "内模式"
            ],
            "false": [
                "模式",
                "外模式",
                "用户模式"
            ]
        },{
            "question": "关系的度(degree)是指关系中  【1】  。",
            "true": [
                "属性的个数"
            ],
            "false": [
                "元组的个数",
                "不同域的个数",
                "相同域的个数"
            ]
        },{
            "question": "在传统关系系统中，对关系的错误描述是  【1】  。",
            "true": [
                "关系可以嵌套定义"
            ],
            "false": [
                "关系是笛卡儿积的子集",
                "关系是一张二维表",
                "关系中的元组次序可交换"
            ]
        },{
            "question": "在关系代数中对传统的集合运算要求参与运算的关系  【1】  。",
            "true": [
                "具有相同的度且对应属性取自同一个域"
            ],
            "false": [
                "具有相同的度",
                "具有相同的关系名具有相同的关系名",
                "具有相同的元组个数"
            ]
        },{
            "question": " 关系数据库是  【1】  的集合，其结构是由关系模式定义的。",
            "true": [
                "表"
            ],
            "false": [
                "元组",
                "列",
                "字段"
            ]
        },{
            "question": "若对关系R1按（【1】）进行运算，可以得到关系R2。",
            "true": [
                "σ价格≥7（R1）"
            ],
            "false": [
                "σ商品名＝‘毛巾‘V’钢笔 ’（R1）",
                "σ商品编号＝‘01020211‘v’02110200’（R1）",
                "π1.2.3.（R1）"
            ]
        },{
            "question": "关系规范化是在数据库设计的（【1】）阶段进行。",
            "true": [
                "逻辑设计"
            ],
            "false": [
                "需求分析",
                "概念设计",
                "物理设计"
            ]
        },{
            "question": "下列关于关系的描述中，正确的是（【1】）。",
            "true": [
                "关系中两个列的值可以取自同一域"
            ],
            "false": [
                "交换关系中的两行构成新的关系",
                "交换关系中的两列构成新的关系",
                "关系中一个列可以由两个子列组成"
            ]
        },{
            "question": "在SQL的查询语句中，允许出现聚集函数的是  【1】  。",
            "true": [
                "SELECT子句和HAVING短语"
            ],
            "false": [
                "WHERE子句",
                "SELECT子句",
                "HAVING短语"
            ]
        },{
            "question": "若给出关系Student(S_no，Shame，Sage，S_sex，SD_name，S_add，S_tel)，并用SQL语言定义Student关系如下：\nCREATE Student (S_no CHAR (6)，\n              Sname CHAR (30) NOT NULL，\n              Sage CHAR(30)，\n              S_sex CHAR(1)，\n              SD_name CHAR (20)，\n              S_add CHAR (30)，\n              S_tel CHAR (20)，\n              PRIMARY KEY(S_no))；\n采用  【1】  向Student中插入记录能被正确地执行。",
            "true": [
                "INSERT INTO Smdent (S_no，Sname，Sage，S_sex，SD_name，S_add，S_tel)\n    VALUES ('010456'，'黎敏'，'18'，\"，\"，\"，\")"
            ],
            "false": [
                "INSERT INTO Student (S_no，Sname，Sage，S_sex，S_r)name，S_add，S_tel)\n    VALUES  ('010456'，'黎敏'，'18'，'男'，'计算机学院'，'北京'，'88661200')",
                "INSERT INTO Student (S_no，Sname，Sage，S_sex，SD_name，S_add，S_tel)\n    VALUES  (，'黎敏'，'18'，'F'，'计算机学院'，'北京'，'88661200')",
                "INSERT INTO Student(S_no，Sname，Sage，S_sex，SD_name，S_add，S_tel)\n    VALUES ('010456'，，'18'，'F'，'计算机学院'，'北京'，'88661200')"
            ]
        },{
            "question": "某高校五个系的学生信息存放在同一个基本表中，采取  【1】  的措施可使各系的管理员只能读取本系学生的信息。",
            "true": [
                "建立各系的行级视图，并将对该视图的读权限赋予该系的管理员"
            ],
            "false": [
                "建立各系的列级视图，并将对该视图的读权限赋予该系的管理员",
                "员将学生信息表的部分列的读权限赋予各系的管理",
                "将修改学生信息表的权限赋予各系的管理员"
            ]
        },{
            "question": "关于对SQL对象的操作权限的描述正确的是  【1】  。",
            "true": [
                "权限的种类分为INSERT、DELETE和UPDATE三种"
            ],
            "false": [
                "权限只能用于实表不能应用于视图",
                "使用REVOKE语句获得权限",
                "使用COMMIT语句赋予权限"
            ]
        },{
            "question": "通过重建视图能够实现  【1】  。",
            "true": [
                "数据的逻辑独立性"
            ],
            "false": [
                "数据的物理独立性",
                "程序的逻辑独立性",
                "程序的物理独立性"
            ]
        },{
            "question": "不属于安全性控制机制的是  【1】  。",
            "true": [
                "完整性约束"
            ],
            "false": [
                "视图",
                "密码验证",
                "用户授权"
            ]
        },{
            "question": "为防止非法用户进入数据库应用系统，应采用的安全措施是  【1】  。",
            "true": [
                "用户标识与鉴别"
            ],
            "false": [
                "授权机制",
                "视图机制",
                "数据加密"
            ]
        },{
            "question": "要使用户张先生只能查询表A中的部分记录，应采取的策略是  【1】  。",
            "true": [
                "构建该部分记录的行级视图，并将该视图的查询权限赋予张先生"
            ],
            "false": [
                "将表A的查询权限赋予张先生",
                "编写查询表A的存储过程",
                "将张先生的用户级别设定为DBA"
            ]
        },{
            "question": "如果数据库应用系统的用户表中存有用户登录口令，则应该  【1】  。",
            "true": [
                "只允许DBA直接查看登录口令"
            ],
            "false": [
                "撒消任何用户对用户表的访问权限，限止登录口令泄漏",
                "对用户登录口令进行加密存储",
                "将用户记录的操作权限仅赋予该用户本人"
            ]
        },{
            "question": "在数据库系统中，数据完整性约束的建立需要通过数据库管理系统提供的数据   【1】  语言来实现。",
            "true": [
                "定义"
            ],
            "false": [
                "操作",
                "查询",
                "控制"
            ]
        },{
            "question": "将表Emp的empname属性列的修改权限授予用户LIU，并允许LIU再将此权限转授其他人，实现的SQL语句是  【1】  。",
            "true": [
                "GRANT update(empname) on Emp TO LIU WITH GRANT OPTION"
            ],
            "false": [
                "GRANT update on Emp TO LIU WITH CHECK OPTION",
                "GRANT update(empname) on Emp TO LIU WITH CHECK OPTION",
                "GRANT update on Emp TO LIU WITH GRANT OPTION"
            ]
        },{
            "question": "连接数据库过程中需要指定用户名和密码，这种安全措施属于  【1】  。",
            "true": [
                "用户标识与鉴别"
            ],
            "false": [
                "授权机制",
                "视图机制",
                "数据加密"
            ]
        },{
            "question": "设有关系：工资范围(职务，最低工资，最高工资)，职工(职工号，职务，工资)，要求任一职工，其工资值必须在其职务对应的工资范围之内，实现该需求的方法是  【1】  。",
            "true": [
                "建立职工表上的触发器程序审定该需求"
            ],
            "false": [
                "建立工资范围表上的触发器程序审定该需求",
                "建立工资范围.职务向职工.职务的参照完整性约束",
                "建立职工.职务向工资范围.职务的参照完整性约束"
            ]
        },{
            "question": "某应用系统的应用人员分为3类：录入、处理和查询，则用户权限管理的方案适合采用  【1】  。",
            "true": [
                "建立每类人员的视图并授权给每个人 "
            ],
            "false": [
                "建立用户角色并授权",
                "对关系进行分解，每类人员对应一组关系",
                "针对所有人员建立用户名并授权"
            ]
        },{
            "question": "将数据库对象的操作权限授予用户，属于安全控制机制中的  【1】  。",
            "true": [
                "自主存取控制"
            ],
            "false": [
                "用户标识与鉴别",
                "强制存取控制",
                "审计"
            ]
        },{
            "question": "撤销U5对Emp表的查询权限，并收回U5授予其他用户的该权限，SQL语句是  【1】  。",
            "true": [
                "REVOKE SELECT ON TABLE Emp FROM U5 CASCADE；"
            ],
            "false": [
                "REVOKE SELECT ON TABLE Emp FROM U5 RESTRICT",
                "REVOKE QUERY ON TABLE Emp FROM U5 CASCADE；",
                "GRANT SELECT ON TABLE Emp TO U5 WITH GRANT OPTION；"
            ]
        },{
            "question": "在数据库系统中，拥有最高权限的用户是  【1】  。",
            "true": [
                "DBA"
            ],
            "false": [
                "GUEST",
                "PUBLIC",
                "ROLE"
            ]
        },{
            "question": "关于视图的叙述，错误的是______。 ",
            "true": [
                "视图能够提高对数据的访问效率"
            ],
            "false": [
                "视图可以实现数据的逻辑独立性",
                "视图提供了一种数据安全机制 ",
                "视图不存储数据，但可以通过视图访问数据"
            ]
        },{
            "question": "连接数据库时的安全验证是通过__【1】____来实现的。 ",
            "true": [
                "用户标识与紧别"
            ],
            "false": [
                "存取控制",
                "数据加密",
                "审计"
            ]
        },{
            "question": "数据库管理系统提供授权功能以便控制不同用户访问数据的权限，其主要目的为了实现数据库的____【1】__。",
            "true": [
                "安全性"
            ],
            "false": [
                "一致性",
                "完整性",
                "可靠性"
            ]
        },{
            "question": "将Students表的查询权限授予用户U1和U2，并允许该用户将此权限授予其他用户。实现此功能的SQL语句如下__【1】__。",
            "true": [
                "GRANT SELECT ON TABLE Students TO U1，U2 WITH GRANT OPTION"
            ],
            "false": [
                "GRANT SELECT TO TABLE Students ON U1，U2 WITH GRANT OPTION",
                "GRANT SELECT ON TABLE Students TO U1，U2 WITH PUBLIC",
                "GRANT SELECT TO TABLE Students ON U1，U2 WITH PUBLIC"
            ]
        },{
            "question": "下列SQL语句中，能够实现“收回用户ZHAO对学生表（STUD）中学号（XH）的修改权”这一功能的是（【1】）。",
            "true": [
                "REVOKE UPDATE（XH）ON STUD FROM ZHAO"
            ],
            "false": [
                "REVOKE UPDATE（XH）ON STUD TOZHAO",
                "REVOKE UPDATE（XH）ON STUD TO PUBLIC",
                "REVOKE UPDATE（XH）ON STUD FROM PUBLIC"
            ]
        },{
            "question": "将存储过程p1的执行权限授予用户U2的SQL语句为。",
            "true": [
                "EXECUTE"
            ],
            "false": [
                "INSERT",
                "UPDATE",
                "DELETE"
            ]
        },{
            "question": "在数据传输过程中，为了防止被窃取可以通过【1】来实现的。",
            "true": [
                "数据加密"
            ],
            "false": [
                "审计",
                "存取控制",
                "用户标识与鉴别"
            ]
        },{
            "question": "在SQL中，用户【1】获取权限。",
            "true": [
                "可通过对象的所有者执行GRANT语句"
            ],
            "false": [
                "只能通过数据摩管理员授权",
                "可通过自己执行GRANT语句",
                "可由任意用户授权"
            ]
        },{
            "question": "不能用作数据完整性约束实现技术的是  【1】  。",
            "true": [
                "视图"
            ],
            "false": [
                "触发器",
                "实体完整性约束",
                "参照完整性约束"
            ]
        },{
            "question": "不能激活触发器执行的操作是  【1】  。",
            "true": [
                "SELECT"
            ],
            "false": [
                "DELETE",
                "UPDATE",
                "INSERT"
            ]
        },{
            "question": "允许取空值但不允许出现重复值的约束是  【1】  。",
            "true": [
                "UNIQUE"
            ],
            "false": [
                "NULL",
                "PRIMARY KEY",
                "FOREIGN KEY"
            ]
        },{
            "question": "SQL语言中实现候选码约束的语句是  【1】  。",
            "true": [
                "用UNIQUE NOT NULL 约束指定"
            ],
            "false": [
                "用UNIQUE约束指定",
                "用Primary Key 指定",
                "用Candidate Key 指定"
            ]
        },{
            "question": "关于存储过程的描述，错误的是  【1】  。",
            "true": [
                "存储过程属于客户端程序"
            ],
            "false": [
                "存储过程可以屏蔽表的细节，起到安全作用",
                "存储过程可以提高系统的执行效率",
                "存储过程可以简化用户的操作"
            ]
        },{
            "question": "约束“主码中的属性不能取空值”，属于__【1】__",
            "true": [
                "实体完整性规则"
            ],
            "false": [
                "参照完整性规则",
                "用户定义完整性规则",
                "函数依赖"
            ]
        },{
            "question": "删除表上一个约束的SQL语句中，不包含关键字__【1】__。",
            "true": [
                "DELETE"
            ],
            "false": [
                "ALTER",
                "DROP",
                "TABLE"
            ]
        },{
            "question": "以下对存储过程的叙述中，不正确的是__【1】__。",
            "true": [
                "存储过程不能嵌套调用"
            ],
            "false": [
                "存储过程可以一次编译，多次执行",
                "存储过程是一组为了完成特定功能的SQL语句组成的程序",
                "存储过程可以定义变量"
            ]
        },{
            "question": "设员工表（员工号，姓名，级别，工资）中，级别增加一级，工资增加500元，实现该约束的可行方案是__【1】__。",
            "true": [
                "在员工表上定义插入和修改作的触发器"
            ],
            "false": [
                "在员工表上定义一个函数",
                "在员工表上定义一个视图",
                "在员工表上定义一个索引"
            ]
        },{
            "question": "以下对触发器的叙述中，不正确的是__【1】__。",
            "true": [
                "触发器可以传递参数"
            ],
            "false": [
                "触发器是SQL语句的集合",
                "用户不能调用触发器",
                "可以通过触发器来强制实现数据的完整性和一致性"
            ]
        },{
            "question": "下列公式中一定成立的是  【1】  。",
            "true": [
                "σF(E1-E2)≡σF(E1)-σF(E2)"
            ],
            "false": [
                "σF(E1×E2)≡σF(E1)×σF(E2)",
                "πA1，A2(σF(E))≡σF(πA1，A2(E))",
                "πA1，A2，B1，B2(EE)≡πA1，A2(E)πB1，B2(E)"
            ]
        },{
            "question": "设关系模式R(ABCDE.上的函数依赖集F={A→BC，BCD→E，B→D，A→D，E→A}，将R分解成两个关系模式：R1=(ABD)，R2=(ACE)，则R1和R2的最高范式分别  【1】  。",
            "true": [
                "2NF和BCNF"
            ],
            "false": [
                "3NF和BCNF",
                "3NF和2NF",
                "2NF和3NF"
            ]
        },{
            "question": "设关系模式R(A，B，C)，下列结论错误的是  【1】  。",
            "true": [
                "若BC→A，则B→A，C→A"
            ],
            "false": [
                "若B→A，C→A，则BC→A",
                "若A→B，A→C，则A→BC",
                "若A→B，B→C，则A→C"
            ]
        },{
            "question": "存在非主属性对码的部分依赖的关系模式是  【1】  。",
            "true": [
                "1NF"
            ],
            "false": [
                "2NF",
                "3NF",
                "BCNF"
            ]
        },{
            "question": "关系模式R属性集为{A，B，C}，函数依赖集F={AB→C，AC→B，B→C}，则R属于  【1】  。",
            "true": [
                "3NF"
            ],
            "false": [
                "BCNF",
                "2NF",
                "1NF"
            ]
        },{
            "question": "两个函数依赖集等价是指  【1】  。",
            "true": [
                "函数依赖集的闭包相等"
            ],
            "false": [
                "同一关系上的函数依赖集",
                "函数依赖个数相等",
                "函数依赖集相互包含"
            ]
        },{
            "question": "设关系模式R＜U，F＞，其中U={A，B，C，D，E}，F={A→BC，C→D，BC→E，E→A}，则分解ρ{R1(ABCE)，R2(CD)}满足  【1】  。",
            "true": [
                "具有无损连接性、保持函数依赖"
            ],
            "false": [
                "不具有无损连接性、保持函数依赖",
                "具有无损连接性、不保持函数依赖",
                "不具有无损连接性、不保持函数依赖"
            ]
        },{
            "question": "存在非主属性部分依赖于码的关系模式属于  【1】  。",
            "true": [
                "1NF"
            ],
            "false": [
                "2NF",
                "3NF",
                "BCNF"
            ]
        },{
            "question": "若某个关系的主码为全码，则应包含  【1】  。",
            "true": [
                "全部属性"
            ],
            "false": [
                "多个属性",
                "两个属性",
                "单个属性"
            ]
        },{
            "question": "【1】  不符合Armstrong 推理规则。",
            "true": [
                "若XZ→Y，则有X→Z"
            ],
            "false": [
                "若X→Y，WY→Z，则有XW→Z",
                "若X→Z，X→Y，则有X→YZ",
                "若X→Y，Z .Y，则有X→Z"
            ]
        },{
            "question": "给定关系模式R(U，F)，其中U为关系R属性集，F是U上的一组函数依赖，若 X→Y，  【1】  是错误的，因为该函数依赖不蕴涵在F中。",
            "true": [
                "Z.U成立，则X→YZ"
            ],
            "false": [
                "Y→Z成立，则X→Z",
                "X→Z成立，则X→YZ",
                "WY→Z成立，则XW→Z"
            ]
        },{
            "question": "下列关于1NF关系的描述，正确的是  【1】  。",
            "true": [
                "关系是笛卡儿积的子集"
            ],
            "false": [
                "关系中允许出现重复的元组",
                "关系中允许出现重名的列",
                "关系中的列可以是一个关系"
            ]
        },{
            "question": "若关系模式R＜{A，B，C}，{A→B，B→C)＞，则将R分解为R1(A，B)和R2(B，C)，则该分解  【1】  。",
            "true": [
                "既满足无损连接，又保持函数依赖"
            ],
            "false": [
                "满足无损连接，但不保持函数依赖",
                "不满足无损连接，但保持函数依赖",
                "既不满足无损连接，又不保持函数依赖"
            ]
        },{
            "question": "给定关系模式销售排名（员工号，商品号，排名），若每一名员工每种商品有一定的排名，每种商品每一排名只有一名员工，则以下叙述中错误的是__【1】__。",
            "true": [
                "只有（员工号，商品号）能作为候选键"
            ],
            "false": [
                "（员工号，商品号）和（商品号，排名）都可以作为候选键",
                "关系模式销售排名属于BCNF",
                "关系模式销售排名属于3NF"
            ]
        },{
            "question": "事务提交之后，其对数据库的修改还存留在缓冲区中，并未写入到硬盘，此时发生系统故障，则破坏了事务的__【1】__ ；系统重启后，由DBMS根据__【2】__ 对数据库进行恢复，将已提交的事务对数据库的修改写入硬盘。",
            "true": [
                "持久性",
                "日志"
            ],
            "false": [
                "原子性",
                "一致性",
                "隔离性",
                "数据库文件",
                "索引记录",
                "数据库副本"
            ]
        },{
            "question": "事务的等待图中出现环，使得环中的所有事务都无法执行下去，这类故障属于__【1】__；解决的办法是选择环中代价最小的事务进行撤销后，再将其置入事务队列稍后执行。假如选中事务T1，对T1撤销过程中需要对其进行__【2】__操作。",
            "true": [
                "事务故障",
                "UNDO"
            ],
            "false": [
                "系统故障",
                "介质故障",
                "病毒",
                "REDO+UNDO",
                "UNDO+REDO",
                "REDO"
            ]
        },{
            "question": "为了保证数据库中数据的安全可靠和正确有效，系统在进行事务处理时，对数据的插入、删除或修改的全部有关内容先写入（【1】）；当系统正常运行时，按一定的时间间隔，把数据库缓冲区内容写入（【2】）：当发生故障时，根据现场数据内容及相关文件来恢复系统的状态。",
            "true": [
                "日志文件",
                "数据文件"
            ],
            "false": [
                "索引文件",
                "数据文件",
                "数据字典",
                "索引文件",
                "日志文件",
                "数据字典"
            ]
        },{
            "question": "事务是一个操作序列，这些橾作（【1】）。“当多个事务并发执行时，任何一个事务的更新操作直到其成功提交前的整个过程，对其他事务都是不可见的。“这一性质通常被称为事务的（【2】）性质。",
            "true": [
                "“要么都做，要么都不做”，是数据库环境中不可分割的逻辑工作单位",
                "隔离性"
            ],
            "false": [
                "“可以做，也可以不做”，是数据库环境中可分割的逻辑工作单位",
                "“可以只做其中的一部分”，是数据库环境中可分割的逻辑工作单位",
                "“要么都做，要么都不做”，是数据库环境中可分割的逻辑工作单位",
                "原子性",
                "一致性",
                "持久性"
            ]
        },{
            "question": "事务一旦提交，即使在写入数据库前数据尚在内存中而发生故障造成系统重启，该事务的执行结果也必须入数据库，该性质称为事务的（【1】），为保证这一性质，必须使用（【2】）。",
            "true": [
                "持久性",
                "日志"
            ],
            "false": [
                "原子性",
                "一致性",
                "隔离性",
                "两段锁协议",
                "数据库备份",
                "镜像"
            ]
        },{
            "question": "系统中同时运行多个事务，若其中一个事务因为自身故障被系统强行退出，而其它事务仍正常运行，这种故障称为（【1】）。该故障发生时，会造成数据库的不一致，解决的方法是（【2】）。",
            "true": [
                "事务故障",
                "由DBMS对该事务进行回滚"
            ],
            "false": [
                "由用户对该事务进行回滚",
                "由程序对该事务进行补偿操作",
                "由DBA对该事务进行回滚",
                "系统故障",
                "介质故障",
                "程序BUG"
            ]
        },{
            "question": "运行中的系统因为故障导致服务器重启，正在执行的事务中断，破坏了事务的原子性，恢复的方法是利用日志进行（【1】）操作；而已经提交的事务在故障发生时尚未写入磁盘，破坏了事务的（【2】），恢复的方法是利用日志进行Redo操作。",
            "true": [
                "Undo",
                "持久性"
            ],
            "false": [
                "Redo",
                "CoDunit",
                "Rollback",
                "原子性",
                "一致性",
                "隔离性"
            ]
        },{
            "question": "数据库重构是指因为性能原因，对数据库中的某个表进行分解，再通过建立与原表同名的（【1】）以保证查询该表的应用程序不变；通过修改更新原表的（【2】）以保证外部程序对数据库的更新调用不变。",
            "true": [
                "视图",
                "存储过程"
            ],
            "false": [
                "索引",
                "存储过程",
                "触发器",
                "触发器",
                "索引",
                "视图"
            ]
        },{
            "question": "事务T1、T2、T3分别对数据D1、D2和D3并发操作，如下所示，其中T1与T2间并发操作  【1】  ，T2与T3间并发操作  【2】  。",
            "true": [
                "不能重复读",
                "将丢失修改"
            ],
            "false": [
                "将读“脏”数据",
                "不存在问题"
            ]
        },{
            "question": "事务T1、T2和T3对相同的一组数据A、B和C进行操作，对于如下的一个并发调度，其中T1与T2间并发操作  【1】  ，T2与T3间并发操作  【2】  。",
            "true": [
                "不能重复读",
                "将丢失修改"
            ],
            "false": [
                "将读“脏”数据",
                "不存在问题"
            ]
        },{
            "question": "若事务T1 对数据D1  已加排它锁 ，事务T2  对数据D2 已加共享锁 ，那么事务T2 对数据D1 __【1】__；事务T 1对数据D2 __【2】__。",
            "true": [
                "加共享锁、排它锁都失败",
                "加共享锁成功，加排它锁失败"
            ],
            "false": [
                "加排它锁成功，加共享锁失败",
                "加共享锁、排它锁都成功"
            ]
        },{
            "question": "事务T1读取数据A后，数据A又被事务T2所修改，事务T1再次读取数据A时，与第一次所读值不同。这种不一致性被称为__【1】__，其产生的原因是破换了事务T1的__【2】__。 ",
            "true": [
                "不可重复读",
                "隔离性"
            ],
            "false": [
                "幻影现象",
                "持久性",
                "丢失修改",
                "读脏数据",
                "原子性",
                "一致性"
            ]
        },{
            "question": "事务T1中有两次查询学生表中的男生人数，在这两次查询执行中间，事务T2对学生表中加入了一条男生记录，导致T1两次查询的结果不一致，此类问题属于（【1】），为解决这一问题，应采用的隔级别是（【2】）。",
            "true": [
                "可重复读",
                "Repeatable Read"
            ],
            "false": [
                "Serializable",
                "幻影现象",
                "丢失修改",
                "Read Committed",
                "读脏数据",
                "Read Uncommitted"
            ]
        },{
            "question": "假设系统中只有事务Ti和T2，两个事务都要对数据D1和D2进行操作。若T1对D1已加排它锁，T1对D2已加共享锁；那么T2对D1（【1】），那么T2对D2（【2】）。",
            "true": [
                "加共享锁成功，加排它锁失败",
                "加共享锁、加排它锁都失败"
            ],
            "false": [
                "加共享锁、加排它锁都成功",
                "加排它锁成功，加共享锁失败"
            ]
        },{
            "question": "并发执行的三个事务T1、T2和T3，事务T1对数据D1加了共享锁，事务T2、T3分别对数据D2、D3加了排它锁，之后事务T1对数据【1】;事务T2对数据【2】。",
            "true": [
                "D1加共享锁成功，D3加排它锁失败",
                "D2加共享锁成功，D3力日排它锁失败"
            ],
            "false": [
                "D2、D3加排它锁都成功",
                "D2、D3加共享锁都成功",
                "D2、D3加排它锁和共享锁都失败",
                "D1、D3加共享锁都失败",
                "D1、D3加共享锁都成功",
                "DJ加排它锁成功，D3加共享锁失败"
            ]
        },{
            "question": "在分布式数据库中，关系的存储采用分片和复制技术，存储在不同的站点上。用户无需知道所有的数据存储在哪个站点上，称为__【1】__。分布式事务的执行可能会涉及到多个站点上的数据操作，在2PC协议中，当事务Ti 完成执行时，事务Ti的发起者协调器Ci向所有参与Ti的执行站点发送<prepare Ti>的消息，当收到所有执行站点返回的<ready Ti>消息后， 再向所有执行站点发送<commit Ti>消息。若参与事务 执行的某个站点故障恢复后日志中有<ready Ti>记录，而没有<commit Ti>记录，则__【2】__。",
            "true": [
                "位置透明",
                "应向协调器询问以决定 的最终结果 "
            ],
            "false": [
                "分片透明",
                "复制透明",
                "异构式分布",
                "事务Ti已完成提交，该站点无需做任何操作",
                "事务Ti已完成提交，该站点应做REDO操作",
                "事务Ti未完成提交，该站点应做UNDO操作"
            ]
        },{
            "question": "数据挖掘申分类的典型应用不包括【1】。【2】可以用于数据挖掘的分类任务。",
            "true": [
                "识别社交网络中的社团结构, 即连接稠密的子网络",
                "SVM"
            ],
            "false": [
                "根据现有的客户信息，分析潜在客户",
                "分析数据，以确定哪些贷款申请是安全的，哪些是有风险的",
                "根据以往病人的特征，对新来的病人进行诊断",
                "K-means",
                "Apriori",
                "EM"
            ]
        },{
            "question": "数据库通常是指有组织地、动态地存储在  【1】  ；应用数据库的主要目的是解决数据  【2】  问题。",
            "true": [
                "外存上的相互联系的数据的集合",
                "共享"
            ],
            "false": [
                "内存上的相互联系的数据的集合",
                "内存上的相互无关的数据的集合",
                "外存上的相互无关的数据的集合",
                "保密",
                "完整性",
                "一致性"
            ]
        },{
            "question": "数据库的视图与基本表之间通过建立  【1】  之间的映像，保证数据的逻辑独立性；基本表与存储文件之间通过建立  【2】  之间的映像，保证数据的物理独立性。",
            "true": [
                "外模式到模式",
                "模式到内模式"
            ],
            "false": [
                "外模式到内模式",
                "外模式到外模式"
            ]
        },{
            "question": "数据库应用系统通常会提供开发接口。若出于安全性考虑，对于只读数据，通常提供  【1】  以供外部程序访问；对于需要更新的数据，则以  【2】  的方式供外部调用，并由提供者完成对系统中多个表的数据更新。",
            "true": [
                "视图",
                "索引"
            ],
            "false": [
                "触发器",
                "基本表"
            ]
        },{
            "question": "在数据库系统中，__【1】__用于对数据库中全部数据的逻辑结构和特征进行描述：其中，外模式、模式和内模式分别描述__【2】__层次上的数据特性。",
            "true": [
                "模式",
                "用户视图、概念视图和内部视图"
            ],
            "false": [
                "外模式",
                "内模式",
                "存储模式",
                "概念视图、用户视图和内部视图",
                "用户视图、内部视图和概念视图",
                "概念视图、内部视图和用户视图"
            ]
        },{
            "question": "在数据库应用系统的体系结构中，常用的是C/S（客户机/服务器）结构和B/S（浏览器/服务器）结构。无论哪种结构，服务器都由（【1】）负责数据库的运行和维护。在C/S结构中，应用程序安装运行在（【2】）端，负责用户与数据库的交互；在B/S结构中，应用程序安装运行在（【3】）端，负责构建用户界面与数据库的交互，客户端使用浏览器展示用户界面并获取用户输入。",
            "true": [
                "DBMS",
                "Web服务器",
                "客户机"
            ],
            "false": [
                "DBA",
                "DataBase",
                "DBS",
                "DB服务器",
                "数据库"
            ]
        },{
            "question": "对于下图所示的S和SC关系，当我们对其进行左外连接时，其结果集的属性列数为 【1】  ，元组个数为 【2】  。",
            "true": [
                "7",
                "10"
            ],
            "false": [
                "6",
                "8",
                "9"
            ]
        },{
            "question": "若集合D1={0，1，2}、集合D2={a，b，c}、集合D3={a，c}，则D1×D2×D3应为  【1】  元组，其结果集的元组个数为  【2】  。若，则结果集的元组个数为  【3】  。",
            "true": [
                "3",
                "18",
                "6"
            ],
            "false": [
                "8",
                "9",
                "12",
                "9",
                "2"
            ]
        },{
            "question": "层次模型和网状模型等非关系模型中，结点用来存储记录，记录间的联系用指针来表达；而关系模型中记录间的联系用（【1】）来描述，查找相关联记录需要进行记录遍历，为提高查找效率，可以建立（【2】）。",
            "true": [
                "关系",
                "索引"
            ],
            "false": [
                "数据模型",
                "主码",
                "概念模型",
                "触发器",
                "存储过程",
                "函数"
            ]
        },{
            "question": "关系数据库中通常包含多个表，表与表之间的关联关系通过（【1】）来实现，通过（【2】）运算将两个关联的表合并成一张信息等价的表。",
            "true": [
                "外码",
                "自然连接"
            ],
            "false": [
                "指针",
                "索引",
                "视图",
                "选择",
                "投影",
                "笛卡尔积"
            ]
        },{
            "question": "在SQL语言中，删除基本表的命令是  【1】  ，修改表中数据的命令是  【1】  。",
            "true": [
                "DROP TABLE",
                "UPDATE"
            ],
            "false": [
                "DESTROY  TABLE",
                "DELETE  TABLE",
                "REMOVE  TABLE",
                "INSERT",
                "DELETE",
                "MODIFY"
            ]
        },{
            "question": " DBMS提供的DDL功能不包含__【1】__。",
            "true": [
                "检索、插入、修改和删除功能"
            ],
            "false": [
                "安全保密定义功能",
                "数据库的完整性定义功能",
                "外模式、模式和和内模式的定义功能"
            ]
        },{
            "question": "收回用户li对表employee的查询权限，同时级联收旧li授予其他用户的该权限，SQL语句为： \n      【1】   select ON TABLE employee FROM li   【2】  ; ",
            "true": [
                "CASCADE",
                "REVOKE"
            ],
            "false": [
                "GRANT",
                "GIVE",
                "CALL BACK",
                "RESTRICT",
                "WITH GRANT OPTION",
                "WITH CHECK OPTION"
            ]
        },{
            "question": "将表employee中name列的修改权限赋予用户Liu，并允许其将该权限授予他人，应使用的SQL语句为：\n    GRANT   【1】   ON TABLE employee TO Liu   【2】  ;",
            "true": [
                "UPDATE(name)",
                "WITH GRANT OPTION"
            ],
            "false": [
                "SELECT",
                "DELETE",
                "INSERT",
                "FOR ALL",
                "CASCADE",
                "WITH CHECK OPTION"
            ]
        },{
            "question": "若将 Workers表的插入权限赋予用户User1，并允许其将该权限授予他人，那么对应的SQL语句为“GRANT 【1】 TABLE Workers TO User1__【2】__；”。",
            "true": [
                "INSERT ON",
                "WITH GRANT OPTION"
            ],
            "false": [
                "INSERT",
                "UPDATE",
                "UPDATE ON",
                "FOR ALL",
                "PUBLIC",
                "WITH CHECK OPTION"
            ]
        },{
            "question": "给定关系模式R(U,F.，U={A,B,C,D}，F={A→C,A→D,C→B,B→D.，F中的冗余函数依赖为  【1】  ；若将R分解为ρ={AC,CB,BD}，则ρ满足  【2】  。",
            "true": [
                "A→D",
                "具有无损连接性，而且保持函数依赖"
            ],
            "false": [
                "A→C",
                "C→B",
                "B→D",
                "不具有无损连接性，而且不保持函数依赖",
                "不具有无损连接性，但保持函数依赖 ",
                "具有无损连接性，但不保持函数依赖"
            ]
        },{
            "question": "给定关系模式R＜U，F＞，U={A，B，C}，F={AB→C，C→B}。关系R  【1】  ，且分别有  【1】  。",
            "true": [
                "有2个候选关键字AC和AB",
                "0个非主属性和3个主属性"
            ],
            "false": [
                "只有1个候选关键字AC",
                "只有1个候选关键字AB",
                "有2个候选关键字AC和BC",
                "1个非主属性和2个主属性",
                "2个非主属性和1个主属性",
                "3个非主属性和0个主属性"
            ]
        },{
            "question": "给定关系模式R<U，F>，U= {A，B，C，D），F={A→B，BC→D}，则关系R的候选键为__【1】__ 。对关系R分解为R1(A，B，C)和R2 (A，C，D)，则该分解__【2】__ 。",
            "true": [
                "(BC)",
                "具有无损连接性，不保持函数依赖"
            ],
            "false": [
                "(AB)",
                "(AC)",
                "(BD)",
                "不具有无损连接性，不保持函数依赖",
                "有无损连接性，保持函数依赖",
                "不具有无损连接性，保持函数依赖"
            ]
        },{
            "question": "以下关于面向对象数据库系统的叙述中，错误的是__【1】__。",
            "true": [
                "不具有表达对象嵌套的能力"
            ],
            "false": [
                "具有表达复杂对象结构的能力",
                "具有表达和管理对象的能力",
                "具有表达和管理数据库变化的能力"
            ]
        },{
            "question": "在面向对象数据库系统的数据类型中，对象属于__【1】__类型。",
            "true": [
                "复杂"
            ],
            "false": [
                "基本",
                "引用",
                "其他"
            ]
        },{
            "question": "  分布式数据库系统除了包含集中式数据库系统的模式结构之外,还增加了几个模式级别，其中（【1】）定义分布式数据库中数据的整体逻辑结构,使得数据如同没有分布一样。",
            "true": [
                "全局概念模式"
            ],
            "false": [
                "全局外模式",
                "分片",
                "分布"
            ]
        },{
            "question": "以下关于面向对象数据库的叙述中，不正确的是（【1】",
            "true": [
                "类的属性不能是类"
            ],
            "false": [
                "类之间可以具有层次结构",
                "类内部可以具有有嵌套层次结构",
                "类包含属性和方法"
            ]
        },{
            "question": "以下关于面向对象数据库的叙述中，不正确的是（【1】）。",
            "true": [
                "一个对象通常对应实际领域的一个实体，有唯一的标识，即对象标识OID，用户可以修改OID"
            ],
            "false": [
                "类的某个属性的定义可以是该类自身",
                "类是一组具有相同或相似性质的对象的抽象。一个对象是某一类的一个实例",
                "类的属性可以是基本类，如整数、字符串等，也可以是包含属性和方法的一般类"
            ]
        },{
            "question": "全局概念层是分布式数据库的整体抽象，包含了系统中全都数据的特性和逻辑结构，从其分布透明特性来说，包含的三种模式描述信息中不包括（【1】）模式。",
            "true": [
                "访问"
            ],
            "false": [
                "全局概念",
                "分片",
                "分配"
            ]
        },{
            "question": " __【1】__不是分布式数据库管理系统应该遵循的准则。",
            "true": [
                "依赖中心结点"
            ],
            "false": [
                "本地自治",
                "分片透明",
                "位置透明"
            ]
        },{
            "question": "CAP理论是NoSql理论的基础，下列性质不属于CAP的是【1】",
            "true": [
                "原子性号"
            ],
            "false": [
                "分区容错性",
                ".可用性",
                "一致性"
            ]
        },{
            "question": "有关联机分析处理(OLAP)与联机事务处理(OLTP)的正确描述是  【1】",
            "true": [
                "OLAP使用历史性的数据，OLTP使用当前数据"
            ],
            "false": [
                "OLAP面向操作人员，OLTP面向决策人员",
                "OLAP经常对数据进行插入、删除等操作，而OLTP仅对数据进行汇总和分析",
                "OLAP不会从已有数据中发掘新的信息，而OLTP可以"
            ]
        },{
            "question": "下面描述正确的是  【1】  。",
            "true": [
                "数据挖掘是采用适当的算法，从数据仓库的海量数据中提取中潜在的信息和知识"
            ],
            "false": [
                "数据仓库是从数据库中导入大量的数据，并对结构和存储进行组织以提高查询效率",
                "使用数据仓库的目的在于对已有数据进行高速的汇总和统计",
                "OLAP技术为提高处理效率，必须绕过DBMS直接对物理数据进行读取和写入"
            ]
        },{
            "question": "数据仓库通过数据转移从多个数据源中提取数据，为了解决不同数据源格式上的不统一，需要进行  【1】  。",
            "true": [
                "清洗   "
            ],
            "false": [
                "简单转移",
                "集成",
                "聚集和概括"
            ]
        },{
            "question": "不常用作数据挖掘的方法是  【1】  。",
            "true": [
                "．穷举法"
            ],
            "false": [
                "人工神经网络 ",
                "规则推导  ",
                "遗传算法"
            ]
        },{
            "question": "下列关于数据挖掘的描述，正确的是  【1】",
            "true": [
                "数据挖掘可以支持人们进行决策"
            ],
            "false": [
                "数据挖掘可以对任何数据进行",
                "数据挖掘与机器学习是同一的",
                "数据来源质量对数据挖掘结果的影响不大"
            ]
        },{
            "question": "数据仓库的多维数据模式中不包括  【1】  。",
            "true": [
                "链状模式"
            ],
            "false": [
                "星型模式 ",
                "雪花模式",
                "事实星状模式"
            ]
        },{
            "question": "OLAP与OLTP的区别是  【1】  。",
            "true": [
                "OLAP面向决策人员，OLTP面向操作人员"
            ],
            "false": [
                "OLAP针对数据库，OLTP针对数据仓库",
                "OLAP要求处理影响时间快，OLTP要求响应时间合理",
                "OLAP主要用于更新事务，OLTP用于分析数据"
            ]
        },{
            "question": "数据仓库与操作型数据库之间的主要区别是  【1】  。",
            "true": [
                "数据仓库在物理实现上对I/O要求更高"
            ],
            "false": [
                "数据仓库没有概念模型 ",
                "数据仓库没有逻辑模型",
                "数据仓库没有物理模型 "
            ]
        },{
            "question": "数据挖掘的目的在于  【1】  。",
            "true": [
                "从已知的大量数据中发现潜在的规则"
            ],
            "false": [
                "对大量数据进行汇总统计",
                "对大量数据进行归类整理",
                "从已知的大量数据中统计出详细的数据"
            ]
        },{
            "question": "下列不属于数据挖掘技术的是  【1】",
            "true": [
                "RSA"
            ],
            "false": [
                "近邻算法",
                "决策树",
                "人工神经网络"
            ]
        },{
            "question": "数据仓库在收集数据过程中，会遇到一些略微不一致但可以纠正的数据，纠正的过程称为  【1】",
            "true": [
                "数据清洗 "
            ],
            "false": [
                "数据转换",
                "数据抽取  ",
                "数据装载"
            ]
        },{
            "question": " 联机分析处理(OLAP)与联机事务处理(OLTP)的区别是___【1】___。 ",
            "true": [
                "OLAP要求响应时间合理，OLTP要求响应时间快 "
            ],
            "false": [
                "OLAP针对数据库，OLTP针对数据仓库 ",
                "OLAP主要用于更新事务，OLTP用于分析数据 ",
                "OLAP面向操作人员，OLTP面向决策人员"
            ]
        },{
            "question": "数据仓库通常采用三层体系结构，中间层为___【1】___。",
            "true": [
                "0LAP服务器"
            ],
            "false": [
                "数据仓库服务器",
                "查询和报表工具 ",
                "数据挖掘工具"
            ]
        },{
            "question": " 回答“银行根据历史数据判断一个新的申请贷款人是否有偿还贷款的能力”这一问题的数据挖掘知识发现类型属于___【1】___。",
            "true": [
                "分类  "
            ],
            "false": [
                "关联规则",
                "特征描述",
                "聚类"
            ]
        },{
            "question": "通过对历史数据的分析，可以预测年收入超过80000元的年轻女性最有可能购买小型运动汽车。这是通过数据挖掘的__【1】__ 分析得到的。",
            "true": [
                "分类"
            ],
            "false": [
                "关联规则",
                "聚类",
                "时序模式"
            ]
        },{
            "question": "__【1】__不是数据仓库的特点。",
            "true": [
                "面向功能 "
            ],
            "false": [
                "集成",
                "非易失",
                "随时间变化"
            ]
        },{
            "question": "根据现有的心脏病患者和非心脏病患者数据来建立模型，基于该模型诊断新的病人是否为心脏病患者，不适于用算法__【1】__分析。",
            "true": [
                "K 均值(K-means )"
            ],
            "false": [
                "ID3",
                "K最近邻(KNN)",
                "支持向量机(SVM)"
            ]
        },{
            "question": "盗窃信用卡的人的购买行为可能不同于信用卡持有者，信用卡公司通过分析不同于常见行为的变化来检测窃贼，这属于__【1】__分析。",
            "true": [
                "离群点 "
            ],
            "false": [
                "分类",
                "关联规则",
                "聚类"
            ]
        },{
            "question": "从时间、地区和商品种类三个维度来分析某电器商品销售数据属于__【1】_",
            "true": [
                "联机分析处理（OLAP）"
            ],
            "false": [
                "ETL ",
                "联机事务处理（OLTP）",
                "数据挖掘"
            ]
        },{
            "question": "以下关于数据仓库的叙述中，不正确的是（【1】）。",
            "true": [
                "数据仓库是面向业务的，支持联机事务处理（OLTP）"
            ],
            "false": [
                ".数据仓库是商业智能系统的基础",
                ".数据仓库是面向分析的，支持联机分析处理（0LAP）",
                "数据仓库中的数据视图往往是多维的"
            ]
        },{
            "question": "当不知道数据对象有哪些类型时,可以使用（【1】）是的同类数据对象与其它类型数据对象分离。",
            "true": [
                "聚类"
            ],
            "false": [
                "分类 ",
                ".关联规则 ",
                ".回归"
            ]
        },{
            "question": "数据挖掘的分析方法可以划分为关联分析、序列模式分析、分类分析和聚类分析四种。如果需要一个示例库（该库中的每个元组都有一个给定的类标识）做训练集时，这种分析方法属于（【1】）",
            "true": [
                "分类分析  "
            ],
            "false": [
                "关联分析",
                "序列模式分析",
                "聚类分析"
            ]
        },{
            "question": "MongoDB是一种NoSQL数据库，具体地说，是（【1】）存储数据库。",
            "true": [
                "文档 "
            ],
            "false": [
                "键值",
                "XML",
                "图形 "
            ]
        },{
            "question": "以下NoSQL数据库中，（【1】）是一种高性能的分布式内存对象缓存数据库，通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度，提高可扩展性。",
            "true": [
                ".Memcached    "
            ],
            "false": [
                ".MongoDB. ",
                "Neo4j  ",
                "Hbase"
            ]
        },{
            "question": "数据仓库中的数据组织是基于【1】模型的。",
            "true": [
                "多维"
            ],
            "false": [
                "网状",
                "层次 ",
                ".关系"
            ]
        },{
            "question": "Redis是一种 NoSQL数据库，具体地说，是__【1】__存储数据库。",
            "true": [
                "键-值"
            ],
            "false": [
                "文档",
                "图形",
                "XML"
            ]
        },{
            "question": "数据模型的三要素包括  【1】  。",
            "true": [
                "数据结构、数据操纵、完整性约束"
            ],
            "false": [
                "外模式、模式、内模式",
                "网状模型、层次模型、关系模型",
                "实体、联系、属性"
            ]
        },{
            "question": "下列关于数据库对象的描述，错误的是__【1】__。",
            "true": [
                "D．—个关系可以有多个主码"
            ],
            "false": [
                "A．存储过程、函数均可接受输入参数 ",
                "B．触发器可以在数据更新时被激活",
                "C．域可以由用户创建，可以加约束条件"
            ]
        },{
            "question": "下列描述中，不属于最小函数依赖集应满足的条件是__【1】__。",
            "true": [
                "每个函数依赖的左部都是单属性"
            ],
            "false": [
                "不含传递依赖 ",
                "不含部分依赖",
                "每个数据依赖的右部都是单属性"
            ]
        },{
            "question": "下列关于函数依赖的描述，错误的是__【1】__。",
            "true": [
                "若BC→A，则B→A，C→A"
            ],
            "false": [
                "若A→B，B→C，则A→C",
                "若A→B，A→C，则A→BC",
                "若B→A，C→A，则BC→A "
            ]
        },{
            "question": "假设描述职工信息的属性有：职工号、姓名、性别和出生日期；描述部门信息的属性有：部门号、部门名称和办公地点。一个部门有多个职工，每个职工只能在一个部门工作；一个部门只能有一个部门经理，部门经理应该为本部门的职工，取值为职工号。则在设计E-R图时，应将职工和部门作为实体，部门和职工之间的工作联系是__【1】__",
            "true": [
                "1：N联系 "
            ],
            "false": [
                "实体",
                "．M：M联系 ",
                "属性"
            ]
        },{
            "question": "设描述职工信息的属性有：职工号、姓名、性别和出生日期；描述部门信息的属性有：部门号、部门名称和办公地点。一个部门有多个职工，每个职工只能在一个部门工作；一个部门只能有一个部门经理，部门经理应该为本部门的职工，取值为职工号。则在设计E-R图时，应将职工和部门作为实体，部门和职工之间的工作联系_，要描述部门经理与部门之间的任职联系，应采用__【2】__。",
            "true": [
                "M：M联系"
            ],
            "false": [
                "实体",
                "1：N联系",
                "属性"
            ]
        },{
            "question": "设描述职工信息的属性有：职工号、姓名、性别和出生日期；描述部门信息的属性有：部门号、部门名称和办公地点。一个部门有多个职工，每个职工只能在一个部门工作；一个部门只能有一个部门经理，部门经理应该为本部门的职工，取值为职工号。则在设计E-R图时，应将职工和部门作为实体，部门和职工之间的工作联系，要描述部门经理与部门之间的任职联系，应采用。由该E-R图转换并优化后的关系模式为__【3】__。",
            "true": [
                "职工（职工号，姓名，性别，出生日期，所在部门)\n部门（部门号，部门名称，办公地点，部门经理） "
            ],
            "false": [
                "职工（职工号，姓名，性别，出生日期）\n                部门（部门号，部门名称，办公地点，部门经理)\n                工作（职工号，部门号）; ",
                "职工（职工号，姓名，性别，出生日期，部门经理)\n                部门（部门号，部门名称，办公地点）\n                工作（职工号，部门号）;",
                "职工（职工号，姓名，性别，出生日期）\n部门（部门号，部门名称，办公地点）\n工作（职工号，部门号，部门经理) "
            ]
        },{
            "question": "两个函数依赖集F和G等价是指（【1】）。",
            "true": [
                "F+=G+  "
            ],
            "false": [
                "F=G ",
                "F—>G",
                "G—>F"
            ]
        },{
            "question": "通过反复使用保证无损连接性，又保持函数依赖的分解，能保证分解之后的关系模式至少达到（【1】）。",
            "true": [
                "3NF  "
            ],
            "false": [
                "INF ",
                "2NF",
                "BCNF"
            ]
        },{
            "question": "若关系R（H，L，M，P）的主键为全码（All-key），则关系R的主键应（【1】）。",
            "true": [
                "为HLMP"
            ],
            "false": [
                "在集合{H，L，M，P}中任选一个",
                "在集合{HL，HM，HP，LM，LP，MP}中任选一个",
                "在集合{HLM，HLP，HMP，LMP）中任选一个"
            ]
        },{
            "question": "对于关系模式R（X,Y,Z），下列结论错误的是（【1】）。",
            "true": [
                "若XY→Z，则X→Z,Y→Z"
            ],
            "false": [
                "若X→Y,Y→Z，则X→Z",
                "若X→Z，则XY→Z",
                "若X→Y,X→Z，则X→YZ"
            ]
        },{
            "question": "若给定的关系模式为R<U，F>，U={A，B，C），F={AB→C，C→B），则关系R（【1】）。",
            "true": [
                "有2个候选关键字AC和AB，并且有3个主属性"
            ],
            "false": [
                "有2个候选关键字AC和BC，并且有3个主属性",
                "只有1个候选关键字AC，并且有1个非主属性和2个主属性",
                "只有1个候选关键字AB，并且有1个非主属性和2个主属性"
            ]
        },{
            "question": "设关系模式R＜U，F＞，其中U为属性集，F是U上的一组函数依赖，那么Armstrong公理系统的伪传递律是指（【1】）。",
            "true": [
                "若X→Y，WY→Z，则XW→Z为F所蕴涵"
            ],
            "false": [
                "若X→Y，Y→Z为F所蕴涵，则X→Z为F所蕴涵",
                "若X→Y，X→Z，则X→YZ为F所蕴涵",
                "若X→Y为F所蕴涵，且Z.U，则XZ→YZ为F所蕴涵"
            ]
        },{
            "question": "关系R（A1，A2，A3）上的函数依赖集F={A1A3→A2,A1A2→A3}，若R上的一个分解为p={（A1，A2），（A1，A3）}，则分解p（【1】）。",
            "true": [
                "是有损联接的"
            ],
            "false": [
                "是无损联接的",
                "是保持函数依赖的",
                "无法确定是否保持函数依赖"
            ]
        },{
            "question": "假设关系R（A1，A2，A3）上的函数依赖集F={A1→A2，A1→A3，A2→A3}，则函数依赖（【1】）。",
            "true": [
                "A1→A3是冗余的"
            ],
            "false": [
                "A1→A2是冗余的",
                "A2→A3是冗余的",
                "A1→A2，A1→A3，A2→A3都不是冗余的"
            ]
        },{
            "question": "给定关系模式R<U，F>;，其中U为关系R的属性集，F是U上的一组函数依赖，X、Y、Z、W是U上的属性组。下列结论正确的是【1】。",
            "true": [
                "若X→y，WY→z成立，则xw→Z成立"
            ],
            "false": [
                "若wx→y，y→Z成立，则X→Z成立",
                "若wx→y，y→Z成立，则W→Z成立",
                "若X→y，Z.U成立，则X→YZ成立"
            ]
        },{
            "question": "满足BCNF范式的关系【1】。 ",
            "true": [
                "没有传递函数依赖"
            ],
            "false": [
                "可包含组合属性",
                "能够保证关系的实体完整性",
                "允许属性对主键的部分依赖"
            ]
        },{
            "question": "有两个关系模式R(A,B,C,D)和S(A,C,E,G)，则X=RxS的关系模式是【1】。",
            "true": [
                "X(R.A，B，R.C，D，S.A，S.C，E，G)"
            ],
            "false": [
                ".X(A，B，C，D，E，G)",
                "X(A，B，C D)",
                ".X(B，D，E，G)"
            ]
        },{
            "question": "给定关系模式R<U，F>，其中属性集U={A，B，C，D，E，G，H，}函数依赖集F={A→B，AE→H，BG→DC，E→C，H→E}，下列函数依赖不成立的是【1】",
            "true": [
                "A→BH"
            ],
            "false": [
                "A→AB ",
                "H→C ",
                "AEB→C  "
            ]
        },{
            "question": "将满足3NF的关系系（【1】）后，可将其规范化为BCNF。",
            "true": [
                "消除主属性对码的部分和传递函数依赖"
            ],
            "false": [
                "消除非主属性对码的部分函数依赖",
                "消除非主属性对码的传递函数依赖",
                "消除非平凡且非函数依赖的多值依赖"
            ]
        },{
            "question": "设学生关系模型Stu（学号，姓名，性别，学院）的主码是学号，成绩关系模型SC（学号，课程号，成绩）的主码为（学号，课程号），若关系模型R（学号，姓名，性别，学院，课程号，成绩）的主码为（学号，课程号），则R满足__【1】__。",
            "true": [
                "1NF "
            ],
            "false": [
                "2NF ",
                "3NF",
                "BCNE"
            ]
        },{
            "question": "下列关于函数依赖的叙述中，错误的是( 【1】   )",
            "true": [
                "若A→BC，则A→B，B→C"
            ],
            "false": [
                "若A→BC，则A→B，A→C",
                "若A→B，B→C，则A→BC",
                "若A→B，B→C，则A→C"
            ]
        },{
            "question": "以下关于E-R图的叙述正确的是  【1】  。",
            "true": [
                "E-R图可将现实世界(应用)中的信息抽象地表示为实体以及实体间的联系"
            ],
            "false": [
                "E-R图建立在关系数据库的假设上",
                "E-R图使应用过程和数据的关系清晰，实体间的关系可导出应用过程的表示",
                "E-R图能表示数据生命周期"
            ]
        },{
            "question": "在某学校的综合管理系统设计阶段，教师实体在学籍管理子系统中被称为“教师”，而在人事管理子系统中被称为“职工”，这类冲突被称为  【1】  。",
            "true": [
                "命名冲突"
            ],
            "false": [
                "语义冲突 ",
                "属性冲突",
                "结构冲突"
            ]
        },{
            "question": "在数据库设计过程中，设计用户外模式属于  【1】  。",
            "true": [
                "逻辑结构设计  "
            ],
            "false": [
                "数据库实施 ",
                "概念结构设计",
                "物理设计"
            ]
        },{
            "question": "不能提高查询性能的措施是：  【1】  。",
            "true": [
                "建立相关视图"
            ],
            "false": [
                "根据查询条件建立索引 ",
                "尽量使用不相关于查洵 ",
                "建立查询表的聚簇索引"
            ]
        },{
            "question": "职工实体中有职工号、姓名、部门、参加工作时间、工作年限等属性，其中，工作年限是一个  【1】  属性。",
            "true": [
                "派生"
            ],
            "false": [
                "多值",
                "复合",
                "．NULL"
            ]
        },{
            "question": "需求分析阶段要生成的文档是  【1】  和数据字典。",
            "true": [
                "数据流图"
            ],
            "false": [
                "功能模块图",
                "UML图",
                "E-R图"
            ]
        },{
            "question": "有关概念结构设计，下列说法正确的是  【1】  。",
            "true": [
                "概念结构设计与具体DBMS无关"
            ],
            "false": [
                "概念结构设计是应用程序模块设计的基础",
                "概念结构设计只应用到数据字典",
                "概念结构设计就是确定关系模式"
            ]
        },{
            "question": "【1】  不属于数据库逻辑结构设计的任务。",
            "true": [
                "创建视图"
            ],
            "false": [
                "规范化    ",
                "模式分解 ",
                "模式合并"
            ]
        },{
            "question": "在需求分析阶段应完成的文档是  【1】  。",
            "true": [
                "数据字典和数据流图"
            ],
            "false": [
                "任务书和设计方案 ",
                "E-R图 ",
                "关系模式"
            ]
        },{
            "question": "在教学管理业务分E-R图中，教师实体具有“主讲课程”属性，而在人事管理业务分E-R图中，教师实体没有此属性，做分E-R图合并时应做如下处理：  【1】  。",
            "true": [
                "合并后的教师实体具有两个分E-R图中教师实体的全部属性"
            ],
            "false": [
                "更改人事管理业务分E-R图中教师实体为“职工”实体",
                "合并后的教师实体具有两个分E-R图中教师实体的公共属性",
                "保持两个教师实体及各自原有属性不变"
            ]
        },{
            "question": "E-R图中某实体具有一个多值属性，在转化为关系模式时，应  【1】  。",
            "true": [
                "将实体的码与多值属性单独构成关系模式，即满足4NF"
            ],
            "false": [
                "将多值属性作为对应实体的关系模式中的属性，即满足4NF",
                "用其他属性来替代多值属性，而不需要存储该多值属性",
                "将多值属性独立为一个关系模式，其码作为实体的外码"
            ]
        },{
            "question": "数据库应用系统中通常会将标准编码构建成字典表，包含代码和名称项，如民族(民族代码，民族名称)，针对这类表，为提高查询性能，应采用的优化方式是  【1】  。",
            "true": [
                "代码的聚簇索引 "
            ],
            "false": [
                "代码的普通索引   ",
                "代码的单一索引",
                "代码的哈希分布"
            ]
        },{
            "question": " E-R图中的组合属性应转换为对象—关系数据模型中的  【1】  。",
            "true": [
                "．类 "
            ],
            "false": [
                "属性 ",
                "关系",
                "方法"
            ]
        },{
            "question": "确定系统边界属于数据库设计的  【1】  阶段。",
            "true": [
                "需求分析 "
            ],
            "false": [
                "概念设计",
                "逻辑设计 ",
                "物理设计"
            ]
        },{
            "question": "关于E-R图合并，下列说法不正确的是  【1】  。",
            "true": [
                "E-R图合并可以发现设计是否满足信息需求"
            ],
            "false": [
                "E-R图合并可以从总体上认识企业信息",
                "E-R图合并可以解决各分E-R图之间存在的冲突",
                "E-R图合并可以解决信息冗余"
            ]
        },{
            "question": "针对E-R图中的组合属性(如地址由省、市、街道、门牌号等组成)，在面向对象数据库中用  【1】  来实现。",
            "true": [
                "结构类型"
            ],
            "false": [
                "方法  ",
                "存储过程 ",
                "数组"
            ]
        },{
            "question": "设计E-R图的过程中，需要确定实体所具有的属性，这一抽象称为  【1】  。",
            "true": [
                "聚集  "
            ],
            "false": [
                "分类 ",
                "概括 ",
                "视图集成"
            ]
        },{
            "question": "视图设计属于数据库设计的  【1】  阶段。",
            "true": [
                "逻辑设计"
            ],
            "false": [
                "需求分析",
                "概念设计",
                "物理设计"
            ]
        },{
            "question": "要实现记录的物理顺序与索引项次序一致，应选择的索引类型是  【1】  。",
            "true": [
                "聚簇索引"
            ],
            "false": [
                "HASH索引",
                "B+树索引",
                "单一索引"
            ]
        },{
            "question": " 确定系统边界和关系规范化分别在数据库设计的__【1】____阶段进行。 ",
            "true": [
                "需求分析和逻辑设计  "
            ],
            "false": [
                "需求分析和概念设计 ",
                "需求分析和物理设计",
                "逻辑设计和概念设计"
            ]
        },{
            "question": "概念结构设计阶段完成的文档是__【1】____。 ",
            "true": [
                "E-R图   "
            ],
            "false": [
                "DFD图  ",
                "关系模式 ",
                "数据字典"
            ]
        },{
            "question": "设计关系模式时，派生属性不会作为关系中的属性来存储。员工(工号，姓名，性别，出生日期，年龄)关系中，派生属性是__【1】____。 ",
            "true": [
                "年龄"
            ],
            "false": [
                "姓名",
                "性别 ",
                "出生日期"
            ]
        },{
            "question": "某高校的管理系统中有学生关系为：学生(学号，姓名，性别，出生日期，班级)，该关系的数据是在高考招生时从各省的考生信息库中导入的，来自同一省份的学生记录在物理上相邻存放，为适应高校对学生信息的大量事务处理是以班级为单位的应用需求，应采取的优化方案是__【1】____。 ",
            "true": [
                "对班级建立CLUSTER索引 "
            ],
            "false": [
                "将学号设为主码  ",
                "对学号建立UNIOUE索引 ",
                "对班级建立UNIOUE索引"
            ]
        },{
            "question": "需求分析阶段，用于描述业务处理流程及各项业务处理所使用数据的图是_【1】_____。",
            "true": [
                "数据流图 "
            ],
            "false": [
                "类图 ",
                "E-R图",
                "用例图"
            ]
        },{
            "question": "确定各基本表的索引，属于数据库设计的__【1】____阶段。",
            "true": [
                "物理设计"
            ],
            "false": [
                "需求分析 ",
                "概念设计",
                "逻辑设计"
            ]
        },{
            "question": "E-R模型向关系模型转换时，三个实体之间多对多的联系m:n:p应该转换为一个独立的关系模式，且该关系模式的主键由__【1】__组成。",
            "true": [
                "三个实体的主键"
            ],
            "false": [
                "多对多联系的属性",
                "任意一个实体的主键",
                "任意两个实体的主键"
            ]
        },{
            "question": "引入索引的目的是为了__【1】__",
            "true": [
                "提高查询语句执行效率 "
            ],
            "false": [
                "提高更新语句执行效率",
                "实现数据的逻辑独立性",
                "实现数据的物理独立性"
            ]
        },{
            "question": "需求分析阶段，采用__【1】__对用户各项业务过程中使用的数据进行详细描述。",
            "true": [
                "数据字典"
            ],
            "false": [
                "关系模式",
                "E-R图",
                "数据流图"
            ]
        },{
            "question": "索引设计属于数据库设计的__【1】__阶段。",
            "true": [
                "物理设计"
            ],
            "false": [
                "需求分析",
                "概念设计",
                "逻辑设计"
            ]
        },{
            "question": " 数据流图（DFD）的作用是（【1】）。",
            "true": [
                "描述对数据的处理流程"
               
            ],
            "false": [
                "描述数据对象之间的关系",
                "说明将要出现的逻辑判定",
                "指明系统对外部事件的反应"
            ]
        },{
            "question": "数据字典中“数据项”的内容包括：名称、编号、取值范围、长度和（【1】）。",
            "true": [
                "数据类型  "
            ],
            "false": [
                "处理频率",
                "最大记录数 ",
                "数据流量"
            ]
        },{
            "question": "在某企业的信息综合管理系统设计阶段，员工实体在质量管理子系统中被称为“质检员”，而在人事管理子系统中被称为“员工”，这类冲突被称之为（【1】）。",
            "true": [
                "命名冲突 "
            ],
            "false": [
                "语义冲突",
                "属性冲突  ",
                "结构冲突"
            ]
        },{
            "question": "在数据库应用系统开发过程中，常采用（【1】）来实现对数据库的更新操作，其内部以事务程序的方式来编写。",
            "true": [
                "存储过程 "
            ],
            "false": [
                "视图",
                "索引",
                "触发器"
            ]
        },{
            "question": "以下关于扩展E-R图设计的描述中，正确的是（【1】）。",
            "true": [
                "联系的属性可以是其关联实体的标识符属性"
            ],
            "false": [
                "联系可以看作实体，与另一实体产生联系，称为聚合",
                "属性可以与其它实体产生联系",
                "三个实体之间的联系与三个实体之间的两两联系是等价的"
            ]
        },{
            "question": "在数据库系统运行维护阶段，通过重建视图能够实现【1】",
            "true": [
                "数据的逻辑独立性 "
            ],
            "false": [
                "程序的逻辑独立性 ",
                "程序的物理独立性",
                "数据的物理独立性"
            ]
        },{
            "question": "数据库概念结构设计阶段是在【1】的基础上，依照用户需求对信息进行分类、聚集和概括，建立概念模型。",
            "true": [
                "需求分析"
            ],
            "false": [
                ".逻辑设计",
                "物理设计",
                "运行维护"
            ]
        },{
            "question": "数据模型通常由【1】三要素构成。",
            "true": [
                "数据结构、数据操纵、完整性约束"
            ],
            "false": [
                "网状模型、关系模型、面向对象模型",
                "数据结构、网状模型、关系模型",
                "数据结构、数据操纵、关系模型"
            ]
        },{
            "question": "数据库概念结构设计阶段的工作步骤依次为【1】。",
            "true": [
                "抽象→设计局部视图→合并取消冲突→修改重构消除冗余"
            ],
            "false": [
                "抽象→设计局部视图→修改重构消除冗余→合并取消冲突",
                "设计局部视图→抽象→合并取消冲突→修改重构消除冗余",
                "设计局部视图→抽象→修改重构消除冗余→合并取消冲突"
            ]
        },{
            "question": "__【1】__是按用户的观点对数据和信息建模，强调其语义表达功能，易于用户理解。",
            "true": [
                "概念数据模型"
            ],
            "false": [
                "关系模型",
                "网状模型",
                "面向对象模型"
            ]
        },{
            "question": " 以下关系模型的描述不正确的是__【1】__。",
            "true": [
                "与网状模型和层次模型相比，关系模型更复杂"
            ],
            "false": [
                "关系模型是由若干个关系模式组成的集合",
                "关系是一个实例，对应于程序设计语言中变量的概念",
                ".关系模型是采用表格结构来表达实体集以及实体集之间的联系"
            ]
        },{
            "question": "需求分析阶段生成的文档中，用来描述企业中各项业务流程的是__【1】__。",
            "true": [
                "数据流图"
            ],
            "false": [
                "数据字典",
                "E－R图",
                "关系图"
            ]
        },{
            "question": "下列列描述的因素中，不属于数据库物理设计应该考虑的是__【1】__",
            "true": [
                "视图设计"
            ],
            "false": [
                "事务的执行频度",
                "使用频繁的查询操作",
                "索引设计"
            ]
        },{
            "question": "E－R图中的实体集A、B之前为1：＊联系，转换为关系模型时，在B实体集中增加A实体集的标识符作外码；而在面向对象数据模型中，__【1】__。",
            "true": [
                "在B对象中增加一个引用属性外，对A对象不作任何处理"
            ],
            "false": [
                "在B对象中增加一个引用属性外，在A对象中增加一组引用属性",
                "在A对象中增加一组引用属性外，对B对象不作任何处理",
                "在A对象中增加一组引用属性外，在B对象中增加一组引用属性"
            ]
        },{
            "question": "假设某企业信息管理系统中的5个实体：部门（部门号，部门名，主管，电话），员工（员工号，姓名，岗位号，电话），项目（项目号，名称，负责人），岗位（岗位号，基本工资），亲属（员工号，与员工关系，亲属姓名，联系方式）。该企业有若干个部门，每个部门有若干名员工；每个员工承担的岗位不同其基本工资也不同；每个员工可有多名亲属（如：父亲、母亲等）；一个员工可以参加多个项目，每个项目可由多名员工参与。下面__【1】__属于弱实体对强实体的依赖联系。",
            "true": [
                "员工与亲属的“属于”联系"
            ],
            "false": [
                "部门与员工的“所属”联系",
                "员工与岗位的“担任”联系",
                "员工与项目的“属于”联系"
            ]
        },{
            "question": "推进游标的指令是  【1】  。",
            "true": [
                ""
            ],
            "false": [
                "OPEN ",
                "DECLARE",
                "CLOSE "
            ]
        },{
            "question": "嵌入式SQL中负责向主语言传递SQL语句执行状态的是  【1】  。",
            "true": [
                "SQLCA"
            ],
            "false": [
                "主变量 ",
                "游标",
                "SQL语句"
            ]
        },{
            "question": "在C/S体系结构中，客户端执行的操作是  【1】  。",
            "true": [
                "嵌入式SQL"
            ],
            "false": [
                "触发器",
                "存储过程",
                "扩展存储过程"
            ]
        },{
            "question": "嵌入式SQL中，将记录的属性值赋给主变量时，若属性为空值，而主变量不能取空值，为解决这一矛盾，使用的机制是  【1】  。",
            "true": [
                "指示变量"
            ],
            "false": [
                "SQLCA ",
                "游标 ",
                "动态SQL"
            ]
        },{
            "question": "若有关系模式R(A,B,C.和S(C,D,E.，关系代数表达式E1、E2、E3和E4，且 E1≡E2≡E3≡E4，如果严格按照表达式运算顺序，查询效率最高的是  【1】  。",
            "true": [
                "E3"
            ],
            "false": [
                "E2",
                "E1",
                "E4"
            ]
        },{
            "question": "数据模型的三要素中不包括（【1】）。",
            "true": [
                "数据类型"
            ],
            "false": [
                "数据结构",
                "数据操作",
                "数据约束"
            ]
        },{
            "question": "关系代数表达式的查询优化中，下列说法错误的是（【1】 ）。",
            "true": [
                "如投影运算前后存在其它的二目运算，应优先处理投影运算"
            ],
            "false": [
                "提早执行选择运算",
                "合并乘积与其后的选择运算为连接运算",
                "存储公共的子表达式，避免重新计算"
            ]
        },{
            "question": "对分组查询结果讲行筛选的是（【1】 ），其条件表达式中可以使用聚集函数。",
            "true": [
                "HAVING 子句"
            ],
            "false": [
                " WHERE 子句",
                " GROUP BY 子句",
                " ORDER BY 子句"
            ]
        },{
            "question": "授权语句GRANT中，以下关于WITH GRANT OPTION子句的叙述中，正确的是（【1】 ）。",
            "true": [
                "用于指明获得权限的用户还可以将该权限赋给其他用户"
            ],
            "false": [
                "用于指明该授权语句将权限赋给全体用户",
                "用于指明授权语句中，该用户获得的具体权限类型",
                "用于指明授权语句中，获得授权的具体用户是谁"
            ]
        },{
            "question": "以下有关触发器的叙述中，不正确的是（【1】 ）。",
            "true": [
                "触发器不能在临时表上创建，也不能引用临时表"
            ],
            "false": [
                "触发器可以执行约束、完整性检查",
                "触发器中不能包含事务控制语句",
                "触发器不能像存储过程一样，被直接调用执行"
            ]
        },{
            "question": "以下关于最小函数依赖集的说法中，不正确的是（【1】 ）。",
            "true": [
                "每个函数依赖的左部都是单属性"
            ],
            "false": [
                "不含传递依赖",
                "不含部分依赖",
                "每个函数依赖的右部都是单属性"
            ]
        },{
            "question": "对于关系模式R （X,Y, Z,W），下面有关函数依赖的结论中错误的是（【1】 ）。",
            "true": [
                "若 XY->Z,则 X->Z"
            ],
            "false": [
                "若 X->Y, WY->Z,则 WX->Z",
                "若 X->Y，Y-Z,则 X->Z",
                "若 X->YZ, 则X->Z"
            ]
        },{
            "question": "将一个关系r分解成两个关系rl和r2,再将分解之后的两个关系rl和r2进行自然连接，得到的结果如果比原关系r记录多，则称这种分解为（ 【1】）。",
            "true": [
                "有损连接的分解"
            ],
            "false": [
                "无损连接的分解",
                "不保持函数依赖的分解",
                "保持函数依赖的分解"
            ]
        },{
            "question": "用于提交和回滚事务的语句为（【1】 ）。",
            "true": [
                "COMMIT TRANSACTION 和 ROLLBACK TRANSACTION"
            ],
            "false": [
                "END TRANSACTION 和 ROLLBACK TRANSACTION",
                "SAVE TRANSACTION 和 ROLLUP TRANSACTION",
                "COMMIT TRANSACTION 和 ROLLUP TRANSACTION"
            ]
        },{
            "question": "如果事务T获得了数据项R上的共享锁，则T对R（【1】 ）。",
            "true": [
                "只能读不能写"
            ],
            "false": [
                "只能写不能读",
                "即可读又可写",
                "不能读不能写"
            ]
        },{
            "question": "将具有特定功能的一段SQL语句(多于一条)在数据库服务器上进行预先定义并编译，以供应用程序调用，该段SQL程序可被定义为（【1】 ）。",
            "true": [
                "存储过程"
            ],
            "false": [
                "视图",
                "触发器",
                "事务"
            ]
        },{
            "question": "下面说法错误的是（【1】 ）。",
            "true": [
                "用户执行SELECT语句时可以激活触发器"
            ],
            "false": [
                "存储过程中可以包含流程控制",
                "存储过程被编译后保存在数据库中",
                "触发器由触发事件激活，并由数据库服务器自动执行"
            ]
        },{
            "question": "数据库系统应该定期备份，如果备份过程中仍有更新事务在运行，则备份结果是不一致的，这种备份称为（ 【1】）。",
            "true": [
                "动态备份"
            ],
            "false": [
                "静态备份",
                "增量备份",
                "日志备份"
            ]
        },{
            "question": "关于日志文件，下列说法错误的是（【1】 ）。",
            "true": [
                "无需其它文件可恢复介质故障"
            ],
            "false": [
                "无需其它文件可恢复事务故障",
                "保存了更新后的数据",
                "保存了更新前的数据"
            ]
        },{
            "question": "如果某一事务程序的运行导致服务器重新启动，这类故障属于系统故障，恢复过程中需要根据日志进行的操作为（【1】 ）。",
            "true": [
                "UNDO 和 REDO"
            ],
            "false": [
                "UNDO",
                " REDO",
                " ROLLBACK"
            ]
        },{
            "question": "以下关于NoSQL数据库的说法中，正确的是（【1】 ）。",
            "true": [
                "NoSQL数据库保证BASE特性"
            ],
            "false": [
                "NoSQL数据库保证ACID特性",
                "各种NoSQL数据库具有统一的架构",
                "NoSQL数据库经常使用JOIN操"
            ]
        },{
            "question": "（【1】 ）不是目前NoSQL数据库产品的数据模型。",
            "true": [
                "层次模型"
            ],
            "false": [
                "图模型",
                "文档模型",
                "键值存储模型"
            ]
        },{
            "question": "以下关于大数据的叙述中，错误的是（【1】 ）。",
            "true": [
                "审计可以防止对数据库的非法修改"
            ],
            "false": [
                "审计记录数据库资源和权限的使用情况",
                "审计操作会影响系统性能",
                "审计跟踪信息会扩大对存储空间的要求"
            ]
        },{
            "question": "在设计关系模式时，有时为了提高数据操作的性能，会故意增加冗余数据，使得 关系模式不满足3NF或BCNF,这种方法称之为反规范化，下列不属于反规范化手段的是（【1】 ）。",
            "true": [
                "创建视图"
            ],
            "false": [
                "合并模式",
                "增加冗余属性",
                "增加派生属性"
            ]
        },{
            "question": "嵌入式SQL中，若查询结果为多条记录时，将查询结果交予主语言处理时，应使用的机制是（【1】），引入（【2】）来解决主语言无空值的问题。",
            "true": [
                "主变量  指示变量"
            ],
            "false": [
                "游标  游标",
                "SQLCA   主变量",
                "指示变量 SQLCA"
            ]
        },{
            "question": "下面说法中错误的是（【1】 ）。",
            "true": [
                "两段锁协议能够确保不会产生死锁"
            ],
            "false": [
                "并发事务如果不加控制，可能会破坏事务的隔离性",
                "可串行化调度是正确的调度",
                "两段锁协议能够保证可串行化调度"
            ]
        },{
            "question": "嵌入式SQL中通过 【1】  实现主语言与SQL语句间进行参数传递；SQL语句的执行状态通过  【2】  传递给主语言来进行流程控制；对于返回结果为多条记录的SQL语句，通过  【3】  来由主语言逐条处理。 ",
            "true": [
                "主变量   SQLCA  游标"
            ],
            "false": [
                "游标  主变量 SQLCA",
                "SQLCA 游标   主变量",
                "数据集 数据集 数据集"
            ]
        },{
            "question": "在需求分析阶段，需求调查的内容是  【1】  ，需求分析的结果是  【1】  。",
            "true": [
                "信息要求、处理要求、安全性与完整性要求   数据流图、数据字典"
            ],
            "false": [
                "信息要求、安全性要求  E-R图",
                "安全性与完整性要求   数据字典  ",
                "信息要求、处理要求   数据流图"
            ]
        }
    ]
}